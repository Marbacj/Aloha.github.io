<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BinaryTree</title>
    <url>/2023/12/05/BinaryTree/</url>
    <content><![CDATA[<ul>
<li>判断一颗二叉树是否是有效的二叉搜索树<ul>
<li>有思路,但是不多…<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="comment">// 调用辅助函数，初始时上界和下界为 null，表示没有限制</span></span><br><span class="line">      <span class="keyword">return</span> helper(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode root, Integer lower, Integer upper)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点为空，返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前节点的值不在上下界之间，返回 false</span></span><br><span class="line">      <span class="keyword">if</span> (lower != <span class="literal">null</span> &amp;&amp; root.val &lt;= lower) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (upper != <span class="literal">null</span> &amp;&amp; root.val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递归地判断左右子树，更新上下界</span></span><br><span class="line">      <span class="keyword">return</span> helper(root.left, lower, root.val) &amp;&amp; helper(root.right, root.val, upper);</span><br><span class="line">      <span class="comment">//第一遍想的太局部了,想成了,只需要单调的递归左右子树就可以了 但是会遇到下面这种情况</span></span><br><span class="line">      <span class="comment">//        5</span></span><br><span class="line">      <span class="comment">//       / \</span></span><br><span class="line">      <span class="comment">//      4   6</span></span><br><span class="line">      <span class="comment">//         / \</span></span><br><span class="line">      <span class="comment">//        3   7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>三数之和<ul>
<li>先排序,进行数组去重,将指针指向去重后的元素,然后使用双指针进行求和,如果k数字是负的那我们就进行选择双指针之和为正的  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 检查数组是否为空或长度小于3</span></span><br><span class="line">      <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对数组进行排序</span></span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      <span class="comment">// 遍历数组中的每个元素，将其作为第一个元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">          <span class="comment">// 跳过相同的元素，避免重复的结果</span></span><br><span class="line">          <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 使用双指针法找到剩余两个元素</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>; <span class="comment">// 左指针</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 右指针</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i]; <span class="comment">// 目标和</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[left] + nums[right]; <span class="comment">// 当前和</span></span><br><span class="line">              <span class="keyword">if</span> (sum == target) &#123; <span class="comment">// 找到一个三元组</span></span><br><span class="line">                  <span class="comment">// 对三元组进行排序，保证非降序</span></span><br><span class="line">                  List&lt;Integer&gt; triplet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                  triplet.add(nums[i]);</span><br><span class="line">                  triplet.add(nums[left]);</span><br><span class="line">                  triplet.add(nums[right]);</span><br><span class="line">                  Collections.sort(triplet);</span><br><span class="line">                  <span class="comment">// 添加到结果列表中</span></span><br><span class="line">                  ans.add(triplet);</span><br><span class="line">                  <span class="comment">// 跳过相同的元素，避免重复的结果</span></span><br><span class="line">                  <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                      left++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                      right--;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 移动左右指针，继续寻找</span></span><br><span class="line">                  left++;</span><br><span class="line">                  right--;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123; <span class="comment">// 当前和小于目标和，需要增大左指针</span></span><br><span class="line">                  left++;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前和大于目标和，需要减小右指针</span></span><br><span class="line">                  right--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><em><strong>今日基础学习</strong></em><br>当谈论Java中实现List接口的类时，通常指的是一些常见的类，它们都是java.util包中的一部分。这些类都实现了List接口，这意味着它们都提供了有序的、可重复的元素集合，并且可以通过索引访问元素。以下是其中几个类：</p>
<p><strong>ArrayList</strong>:<br>实现了可调整大小的动态数组。<br>通过数组实现，支持随机访问。<br>非线程安全，适用于单线程环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><em><strong>LinkedList</strong></em>:<br>实现了双向链表。<br>对于频繁的插入和删除操作，性能比ArrayList好。<br>同样支持随机访问，但效率相对较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><em><strong>Stack</strong></em>:<br>继承自Vector类，实现了堆栈数据结构。<br>提供了后进先出（LIFO）的操作。<br>由于Vector是线程安全的，Stack也是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><em><strong>Vector</strong></em>:<br>实现了可调整大小的动态数组。<br>与ArrayList类似，但是是线程安全的。<br>由于线程安全的开销，通常在性能要求较低的场景中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><em><strong>CopyOnWriteArrayList</strong></em>:<br>实现了可调整大小的动态数组。<br>写操作时会创建一个新的数组，读操作不需要加锁。<br>适用于读多写少的场景，因为写操作的开销比较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这些类都提供了一些常用的方法，如添加元素、删除元素、获取元素等。选择使用哪个类取决于你的具体需求和性能考虑。如果需要在多线程环境中使用，可能需要考虑线程安全性。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binarytree</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>FeignAndHystrix</title>
    <url>/2024/03/09/FeignAndHystrix/</url>
    <content><![CDATA[<p><strong>Feign</strong>:</p>
<p>
Feign 是一个声明式的 HTTP 客户端，它使得编写 HTTP 客户端变得更加简单和优雅。通过 Feign，开发者可以使用注解的方式来定义 HTTP 请求的参数、路径、方法等信息，而无需手动编写 HTTP 请求的代码。
Feign 可以与 Spring Cloud 中的服务发现组件（如 Eureka）集成，使得微服务之间的调用更加方便和透明。<b>使用feign可以实现微服务之间的调用</b>,
Feign 是一个很好的微服务间通信的工具，但在复杂的网络环境下，如果发生故障，可能会导致调用失败。这时候就需要一个能够提供容错机制的组件来保障系统的可用性。
</p>
<hr>


<p><strong>Hystrix</strong>:</p>
<p>
Hystrix 是 Netflix 提供的一个用于处理分布式系统的延迟和故障的库。它实现了断路器模式，可以在服务之间进行通信时提供容错和隔离机制。
Hystrix 可以通过定义 fallback 方法来处理调用失败时的情况，使得系统在发生故障时能够进行优雅降级，而不至于影响整个系统的稳定性。
Hystrix 可以与 Feign 集成，通过 FeignClient 的 fallback 属性来指定 Hystrix 的降级逻辑，从而在微服务间通信时提供了容错机制。
因此，Feign 和 Hystrix 可以结合使用，通过 Feign 发起微服务间的 HTTP 调用，同时通过 Hystrix 提供的容错机制来保障系统的可用性和稳定性。这样，就可以在微服务架构中实现更加健壮的服务调用和容错处理。
</p>
<hr>
<p>
因此，Feign 和 Hystrix 可以结合使用，通过 Feign 发起微服务间的 HTTP 调用，同时通过 Hystrix 提供的容错机制来保障系统的可用性和稳定性。这样，就可以在微服务架构中实现更加健壮的服务调用和容错处理。
</p>
具体的代码实现是在添加FeignClient注解的接口中，通过指定fallback属性为对应的降级类来实现容错处理。在降级类中，可以根据具体情况进行相应的处理，比如返回默认值或者抛出异常等。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;eureka-client-ad-sponsor&quot;,</span></span><br><span class="line"><span class="meta">        fallback = SponsorClientHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SponsorClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/ad-sponsor/get/adPlan&quot;,</span></span><br><span class="line"><span class="meta">            method = RequestMethod.POST)</span></span><br><span class="line">    CommonResponse&lt;List&lt;AdPlan&gt;&gt; <span class="title function_">getAdPlans</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestBody</span> AdPlanGetRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>


<p><strong>Ribbon</strong>：</p>
<p>Ribbon 是 Netflix 提供的一个负载均衡组件，它用于在客户端进行负载均衡，以提高微服务之间的通信效率和可靠性。<br>Ribbon 可以根据一定的负载均衡策略（如轮询、随机、权重等）来选择合适的服务实例进行请求转发，从而实现了对服务提供者的负载均衡。<br>在微服务架构中，服务消费者可以通过 Ribbon 来发起对服务提供者的请求，并且 Ribbon 可以根据负载均衡策略选择合适的服务实例进行请求转发。</p>
<p>微服务相互访问，通讯的协议应该是”http”，目前有两种常用的调用：</p>
<blockquote>
1.ribbon+spring restTemplate  

<p>2.feign(ribbon+hystrix) 声明式接口的形式</p>
</blockquote>
这两种也就是对 apache httpClient 的封装，方便微服务的使用吧。

<p>Ribbon+Hystrix方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;//断路器</span><br></pre></td></tr></table></figure>
<p>配置eureka</p>
<p>注入 RestTemplate </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//@EnableDiscoveryClient其他服务注册中心</span></span><br><span class="line"><span class="meta">@EnableHystrix</span>  <span class="comment">//内部有@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;SpringApplication.run(SearchApplication.class, args);&#125;</span><br><span class="line"><span class="comment">//基于Ribbon实现微服务调用</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span>  <span class="comment">//开启默认Ribbon</span></span><br><span class="line">RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;这里有断路器-例子&quot;)</span>   <span class="comment">//使用断路器</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/getAdPlansByRibbon&quot;)</span>            <span class="comment">//Spring MVC 的controller</span></span><br><span class="line"><span class="keyword">public</span> CommonResponse&lt;List&lt;AdPlan&gt;&gt; <span class="title function_">getAdPlansByRibbon</span><span class="params">(<span class="meta">@RequestBody</span> AdPlanGetRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.postForEntity(<span class="string">&quot;http://eureka-client-ad-sponsor/ad-sponsor/get/adPlan&quot;</span>,</span><br><span class="line">        request, CommonResponse.class).getBody();&#125;</span><br></pre></td></tr></table></figure>

<p>Feign方式<br>坐标（简版）   feign引入ribbon+hystrix等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br></pre></td></tr></table></figure>

<p>配置eureka</p>
<p>启动类加上@EnableFeignClients</p>
<p>实现服务调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;eureka-client-ad-sponsor&quot;,fallback = SponsorClientHystrix.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SponsorClient</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/ad-sponsor/get/adPlan&quot;,method = RequestMethod.POST)</span></span><br><span class="line">List&lt;AdPlan&gt; <span class="title function_">getAdPlans</span><span class="params">(<span class="meta">@RequestBody</span> AdPlanGetRequest request)</span> <span class="keyword">throws</span> AdException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明式的接口，外部直接调用方法就可以了，这个加了一个断路器SponsorClientHystrix</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SponsorClientHystrix</span> <span class="keyword">implements</span> <span class="title class_">SponsorClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;AdPlan&gt; <span class="title function_">getAdPlans</span><span class="params">(AdPlanGetRequest request)</span> <span class="keyword">throws</span> AdException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AdException</span>(CodeMsg.EUREKA_CLIENT_AD_SPONSOR_ERROR);&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>techLearning</category>
      </categories>
      <tags>
        <tag>Feign</tag>
        <tag>hystrix</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>JpaStudy</title>
    <url>/2024/03/09/JpaStudy/</url>
    <content><![CDATA[<p>当你在使用 Spring Data JPA 时，通常会定义一个接口并继承 JpaRepository 接口。这个过程并不是直接的Java接口继承，而是利用了 Spring Data JPA 提供的接口继承机制来简化数据访问层的开发。</p>
<p>JpaRepository 接口是 Spring Data JPA 提供的一个标准接口，它提供了一组用于对数据库进行常见操作（如保存、更新、删除、查询等）的方法。这些方法在定义时不需要编写具体的实现，Spring Data JPA 会根据方法的命名规则自动为其生成实现。</p>
<p>当你定义一个接口并继承 JpaRepository 时，Spring Data JPA 会动态地为这个接口生成对应的数据访问方法。这些方法可以直接在你的业务逻辑中使用，而无需手动编写数据访问层的实现代码。</p>
<p>例如，假设你有一个名为 User 的实体类，你可以定义一个继承自 JpaRepository&lt;User, Long&gt; 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里可以添加自定义的查询方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，UserRepository 接口继承了 JpaRepository&lt;User, Long&gt; 接口。User 是你的实体类，Long 是实体类主键的类型。继承了 JpaRepository 接口后，UserRepository 就会拥有一系列用于对 User 实体类进行数据库操作的方法，如 save()、findById()、delete() 等。</p>
<p>Spring Data JPA 还支持使用方法名的约定来进行查询方法的定义。例如，定义一个方法名为 findByUsername(String username) 的方法，Spring Data JPA 将会根据方法名自动解析出对应的查询语句。</p>
<p>这种基于接口的数据访问方式使得数据访问层的开发更加简洁、高效，同时也减少了重复的 CRUD 操作代码。</p>
]]></content>
      <categories>
        <category>techLearning</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Array</title>
    <url>/2024/03/20/Array/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>我是傻逼,从右往左找满足条件的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">            nums[left] = nums[i];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>LinkedList</title>
    <url>/2023/11/27/LinkedList/</url>
    <content><![CDATA[<ul>
<li><p>环形链表I</br><br>一个简单的想法是使用快慢指针，快指针一次走两步，慢指针一次走一步，当快指针指向null时，慢指针指向的节点<br>这个想法可以类比于龟兔赛跑,由于兔子及快导致如果有环,会一直再环里转圈,总会到一个位置相遇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=low)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>)&#123;      <span class="comment">// 注意判空条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            low=low.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环形链表II</br><br>在第一题的基础上加入了求环形链表的入口点<br>与上一题相同,设立快慢指针,假设慢指针到入口的距离是<strong>a</strong>,到快指针的相遇点是<strong>a+b</strong><br>假设环的跨度是<strong>c</strong><br>那么我们可以进行得到的是fast &#x3D; a+b+n<em>c </br><br>slow &#x3D; a+b</br><br>且fast &#x3D; 2</em>slow</br><br>所以有a+b+n<em>c &#x3D; 2</em>(a+b)</br><br>所以有a+b &#x3D; n<em>c</br><br>当我们假设b只有一圈的时候, a &#x3D; n</em>c - b</br><br>这时候我们可以得到的结论是, 当我们重新设立一个新的指针, 指向head, 然后两个指针(slow与nPtr)同时移动<br>那么我们可以进行得到的是a,也即入口指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;   <span class="comment">//值得注意的是本处的快慢指针不能使用不同起点,具体原因想不通</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span>|| fast.next ==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectLearning1</title>
    <url>/2024/03/06/ProjectLearning1/</url>
    <content><![CDATA[<h1 id="优惠券系统"><a href="#优惠券系统" class="headerlink" title="优惠券系统"></a>优惠券系统</h1><p>开始愉快的项目复盘!</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li>@nullable:表示注入的元素可以为null值,不进行处理,当注入方法时候表示可能方法返回值为null</li>
<li>@RestControllerAdvice:是 Spring 框架中用于统一处理异常和全局响应的注解。</li>
<li>@NoArgsConstructor:注解的作用是生成一个无参构造函数。</li>
<li>@AllArgsConstructor:注解的作用是生成一个包含所有参数的构造函数。</li>
<li>@Slf4j:注解的作用是自动生成一个日志对象。</li>
<li>@target:这个注解用于指定被它修饰的注解可以应用在哪些地方。在这里，被修饰的注解可以应用在类或接口上（ElementType.TYPE），以及方法上（ElementType.METHOD）。</li>
<li>@Retention(RetentionPolicy.RUNTIME): 这个注解用于指定被它修饰的注解的生命周期。在这里，被修饰的注解会在运行时保留，这意味着可以通过反射来读取和使用这个注解。</li>
<li>@Documented: 这个注解用于指定被它修饰的注解会被 javadoc 工具包含在文档中。如果一个注解有 @Documented 注解，那么在生成 Java 文档时，该注解会被包含在文档中，以便开发者能够看到它们。</li>
<li>@PostMapping 注解用于将一个方法映射到处理 HTTP POST 请求的控制器方法上。当客户端向服务器发送 POST 请求时，Spring MVC 将根据请求的 URL 映射到带有 @PostMapping 注解的方法，并且该方法会被调用来处理该请求。</li>
<li>@GetMapping 注解用于将一个方法映射到处理 HTTP GET 请求的控制器方法上。当客户端向服务器发送 GET 请求时，Spring MVC 将根据请求的 URL 映射到带有 @GetMapping 注解的方法，并且该方法会被调用来处理该请求。</li>
<li>@Service 注解可以将一个类标记为服务类，使得 Spring 在进行组件扫描时能够将其识别为服务组件并进行相应的实例化和管理。</li>
<li>@Controller 注解用于标记一个类为控制器类</li>
<li>@ResponseBody 注解用于指示 Spring MVC 框架将方法返回的对象直接作为 HTTP 响应的主体内容发送给客户端</li>
<li>@Component注解通常作用于具体的类上，例如普通的Java类、服务类、DAO（数据访问对象）类等。当Spring Boot应用启动时，Spring容器会扫描指定包及其子包下所有被@Component注解标记的类，并将它们实例化为Spring Bean，使得它们可以被其他组件或类自动注入使用。</li>
<li>@Autowired 注解通常作用于类的属性上，例如JavaBean的属性、Service类或Controller类的参数等。当Spring容器扫描到被@Autowired注解标记的属性时，它会尝试自动注入该属性对应的Spring Bean。省流:从bean中拿过来使用</li>
</ul>
<hr>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>统一响应:统一响应通常是指在开发中，为了方便处理不同接口返回的结果，将所有的响应结果进行统一封装，以便客户端能够更方便地处理这些响应。</li>
<li>统一异常处理:统一异常处理是指在开发中，为了方便处理各种异常情况，将所有的异常情况进行统一封装，以便在整个系统中能够更方便地处理异常。</li>
<li>异步如何实现,使用google包下面的stopwatch类进行计时,使用异步线程池进行处理</li>
</ul>
<h3 id="AccessLogFilter"><a href="#AccessLogFilter" class="headerlink" title="AccessLogFilter:"></a>AccessLogFilter:</h3><p>实现Filter接口,重写doFilter方法,在方法中获取请求的url,请求的ip,请求的参数,请求的响应</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>* </p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul>
<li>统一响应: 按照一个固定的格式进行包装,判断是不是需要的格式,如果是需要的格式,就进行处理,如果不是需要的格式,就进行包装,总的来说,beforeBodyWrite是一个包装的过程</li>
<li>java开发中的分包规范(alibaba)</li>
</ul>
<p>DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO层向上传输数据源对象。</p>
<p>DTO（Data Transfer Object）：数据传输对象，Service 或Manager 向外传输的对象。</p>
<p>BO（Business Object）：业务对象，可以由Service层输出的封装业务逻辑的对象。</p>
<p>Query：数据查询对象，各层接收上层的查询请求。注意超过2 个参数的查询封装，禁止使用 Map 类 来传输。</p>
<p><del>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</del></br></p>
<p>这里的vo(value object)：应该是从DDD(领域驱动设计)中的概念,也是指方法间传的对象,具有以下的特点</p>
<ul>
<li><p>不可变性（Immutability）：Value Object 的值在创建后不能被修改，任何修改都会导致创建一个新的对象。这种不可变性保证了对象的一致性和稳定性。</p>
</li>
<li><p>等同性（Equality）：Value Object 通常根据其属性值来判断是否相等，而不是根据对象的标识符。如果两个 Value Object 的属性值相同，那么它们就被认为是相等的。</p>
</li>
<li><p>值语义（Value Semantics）：Value Object 表示的是某个值或概念，而不是实体。它们的主要作用是为了表示某种特定的值，而不是为了标识某个独立的实体。<br>PO（Persistent Object）：持久层对象，由 DAO 层输出的对象。</p>
</li>
</ul>
<blockquote>
  区分一下vo包和constant包

  <p>constant 包通常用于存放项目中的常量，例如配置项、枚举值、错误码、状态码等。这些常量是固定不变的值，在程序中被多次引用。
  将常量放置在一个独立的包中有助于代码的组织和管理，使得开发人员更容易找到和维护这些常量。此外，通过将常量放置在一个独立的包中，可以避免常量与其他类或模块的命名冲突，提高了代码的可读性和可维护性。</p>

  <p>vo 包通常用于存放值对象（Value Object），即一些与业务相关的数据对象，这些对象通常用于数据的传输和封装，而不包含业务逻辑。
  值对象通常包含了多个字段（Attributes），代表了一些实体或概念的属性集合。这些对象用于在不同的层（如控制器、服务、持久化层）之间传输数据，以实现业务功能的处理和交互。
  将值对象放置在一个独立的包中有助于对数据模型进行组织和管理，使得数据结构更加清晰和易于理解。同时，通过使用值对象，可以将业务逻辑与数据传输逻辑分离开来，提高了代码的可维护性和可扩展性。</p>
</blockquote>
## 业务思想
### 优惠券模板微服务
核心点有:
* 优惠券模板的创建
* 生成对应数量的优惠券
* 最后用户才可以进行领取

<h4 id="优惠券模板创建的流程"><a href="#优惠券模板创建的流程" class="headerlink" title="优惠券模板创建的流程:"></a>优惠券模板创建的流程:</h4><ol>
<li>开启异步服务,进行生成模板,生成需要的数量优惠券,并且生成模板的优惠券码</li>
<li>根据优惠券码进行优惠券生成,并且将优惠券码进行保存</li>
</ol>
<h4 id="zuul网关的四个过滤器的核心功能"><a href="#zuul网关的四个过滤器的核心功能" class="headerlink" title="zuul网关的四个过滤器的核心功能"></a>zuul网关的四个过滤器的核心功能</h4><ul>
<li>PRE（前置过滤器）：在请求被路由到目标服务之前执行。这些过滤器可以用来执行认证、授权、日志记录、请求参数校验等操作。如果请求不符合预期，可以在这里进行拦截或修改。</li>
<li>ROUTE（路由过滤器）：在请求被路由到目标服务时执行。这些过滤器通常用来将请求发送到目标服务，可以在发送请求之前或之后对请求进行修改或记录。</li>
<li>POST（后置过滤器）：在目标服务处理完请求并生成响应之后执行。这些过滤器可以对响应进行修改、记录、过滤等操作。例如，添加响应头、统计响应时间等。</li>
<li>ERROR（错误过滤器）：在处理请求过程中发生错误时执行。这些过滤器可以处理错误并提供友好的错误响应，或记录错误信息以便后续排查问题。</li>
</ul>
<p>&#x2F;?<br>你是如何保证优惠券码的唯一性的？你有没有考虑过分布式锁或者雪花算法等方案？<br>你是如何实现熔断兜底策略的？你有没有使用Hystrix或者Sentinel等框架？你是如何配置熔断的触发条件和恢复机制的？<br>你是如何测试和监控你的微服务的？你有没有使用JMeter或者Gatling等压力测试工具？你有没有使用Prometheus或者Grafana等监控工具？<br>你是如何保证你的微服务的高可用和负载均衡的？你有没有使用Ribbon或者Feign等客户端负载均衡工具？你有没有使用Nginx或者Traefik等服务端负载均衡工具？<br>你是如何管理你的微服务的配置信息的？你有没有使用Spring Cloud Config或者Apollo等分布式配置中心？你有没有使用Spring Cloud Bus或者Kafka等消息总线来实现配置的动态刷新？</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>coupon</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectLearning2</title>
    <url>/2024/03/08/ProjectLearning2/</url>
    <content><![CDATA[<h1 id="广告投放系统"><a href="#广告投放系统" class="headerlink" title="广告投放系统"></a>广告投放系统</h1><hr>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="CommonResponseAdvice"><a href="#CommonResponseAdvice" class="headerlink" title="CommonResponseAdvice"></a>CommonResponseAdvice</h3><p>将字段进行包装进行填充,规范化API返回格式：通过统一响应，可以定义API的返回格式，包括状态码、消息、数据等内容，使得不同的接口返回风格一致，提高了接口的可预测性和可读性。</p>
<h3 id="JpaRepository的继承过程"><a href="#JpaRepository的继承过程" class="headerlink" title="JpaRepository的继承过程"></a>JpaRepository的继承过程</h3><p><em><a href="https://bachman.top/2024/03/09/JpaStudy/">关于JpaRepository的继承过程</a></em></p>
<h3 id="Feign和Hystrix"><a href="#Feign和Hystrix" class="headerlink" title="Feign和Hystrix"></a>Feign和Hystrix</h3><p>关于Feign和Hystrix的整合，可以参考以下文章：</br><br><em><a href="https://bachman.top/2024/03/09/FeignAndHystrix/">如何理解服务调用,阶段器和负载均衡</a></em></p>
<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>有关RESTful的介绍，可以参考以下文章：</br><br><em><a href="https://bachman.top/2024/03/09/SpringMVC/">浅谈restful</a></em> </p>
<p></p>




<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li>@Transactional,声明一个方法需要进行事务管理，并指定事务的隔离级别、传播行为和超时时间等属性。</li>
</ul>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul>
<li>接口可以继承自什么?<br>接口可以继承自接口，但不能继承自类。这意味着一个接口可以通过使用关键字 extends 来扩展（继承）另一个接口。通过接口继承，子接口可以获得父接口中声明的方法签名，但不包括方法的实现。</li>
</ul>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><h3 id="binlog原理"><a href="#binlog原理" class="headerlink" title="binlog原理"></a>binlog原理</h3><ol>
<li>主库将数据库中的数据的变化写入到binlog日志文件中<br>2 从库通过连接主库</li>
<li>从库会创建一个i&#x2F;o线程，用于读取主库的binlog日志文件，并将数据的变化同步到自己的数据库中。</li>
<li>主库会创建一个binlog dump线程，用于将binlog日志文件发送给从库的i&#x2F;o线程。</li>
<li>从库的i&#x2F;o线程接收到binlog日志文件后,会写到relaylog日志文件中。</li>
<li>从库的SQL线程会读取relaylog日志文件中的数据变化，并将其应用到自己的数据库中。</li>
</ol>
<h3 id="如何避免主从延迟"><a href="#如何避免主从延迟" class="headerlink" title="如何避免主从延迟"></a>如何避免主从延迟</h3><p>如果我们无法忍受主从同步延迟我们可以又两种方法进行解决</p>
<ul>
<li>强制将读请求路由到主库处理</li>
<li>延迟读取<br>如果主从同步延迟是0.5s,我们就1s后进行读取数据</li>
</ul>
<h3 id="什么情况下会出现主从延迟-如何尽量减少延迟"><a href="#什么情况下会出现主从延迟-如何尽量减少延迟" class="headerlink" title="什么情况下会出现主从延迟,如何尽量减少延迟"></a>什么情况下会出现主从延迟,如何尽量减少延迟</h3><p>其中又两个io我们可以想到,明显是由于两个io的速度不一致导致的</p>
<ul>
<li>其中第一个io是从库接受binlog的速度明显跟不上主库写入binlog的时间</li>
<li>第二个是从库的sql线程执行relaylog的速度明显跟不上从库接受binlog的速度</li>
</ul>
<p><strong>我们可以考虑从优化上述的机器性能进行解决问题</strong></p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="什么是分库"><a href="#什么是分库" class="headerlink" title="什么是分库"></a>什么是分库</h3><p>  分库就是将数据库中的数据分散到不同的数据库中,可以垂直分库,也可以水平分库<br>  垂直分库就是将不同的表分散到不同的数据库中,水平分库就是将不同的数据分散到不同的表中<br>  举个例子</p>
<ul>
<li>垂直分库<br>将不同的业务逻辑进行分库</li>
<li>水平分库<br>将表的主键按照一定的原则进行划分</li>
</ul>
<h3 id="什么是分表"><a href="#什么是分表" class="headerlink" title="什么是分表"></a>什么是分表</h3><p>  分表就是将一张表中的数据分散到不同的表中,可以垂直分表,也可以水平分表<br>  垂直分表就是将不同的字段分散到不同的表中,水平分表就是将不同的数据分散到不同的表中<br>  举个例子</p>
<ul>
<li>垂直分表<br>  就是根据表的属性进行划分</li>
<li>水平分表<br>  就是将按照主键的id进行划分</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列有什么用"><a href="#消息队列有什么用" class="headerlink" title="消息队列有什么用"></a>消息队列有什么用</h3><p>  一共有三个作用</p>
<ul>
<li>解耦</li>
<li>异步处理</li>
<li>削峰填谷<br>  其中我的项目用到了两种作用</li>
<li>其中的第一个作用是进行解耦,binlog的其中一个缺陷是多服务器时会造成数据库压力大<br>而我们知道消息队列使用的时发布-订阅模式进行工作,这时我们新增从数据库我们可以进行直接订阅,从而实现网站业务的可扩展性设计</li>
<li>其中的第二个作用是进行异步处理,在广告投放系统中,我们使用消息队列进行广告投放的异步处理,从而实现广告投放的效率</li>
</ul>
<h3 id="讲一下什么时JMS和AMQP"><a href="#讲一下什么时JMS和AMQP" class="headerlink" title="讲一下什么时JMS和AMQP"></a>讲一下什么时JMS和AMQP</h3><ul>
<li>JMS(Java Message Service)<br>JMS是Java平台中关于面向消息中间件的API，它定义了用于创建、发送、接收消息的Java应用程序接口，用于在JVM的两种或多个应用程序之间，进行异步通信。 </li>
<li>AMQP(Advanced Message Queuing Protocol)<br>AMQP是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。</li>
</ul>
<h3 id="RPC和消息队列的区别"><a href="#RPC和消息队列的区别" class="headerlink" title="RPC和消息队列的区别"></a>RPC和消息队列的区别</h3><ul>
<li>从用途上来看<br>RPC是远程过程调用,用于服务之间的调用,而消息队列是用于服务与服务之间的通信,两者都是用于服务之间的通信</li>
<li>从通信方式上来看<br>RPC时双向直接网络通讯,而消息队列时单向引入中间载体的网络通讯</li>
<li>从架构上来看<br>消息队列时将消息存储起来,RPC则没有这个要求,RPC时双向直接网络童鞋你</li>
<li>从请求处理的时效性来看<br>RPC是同步请求,而消息队列是异步请求</li>
</ul>
<h2 id="kafka常见问题"><a href="#kafka常见问题" class="headerlink" title="kafka常见问题"></a>kafka常见问题</h2><h3 id="kafka是什么"><a href="#kafka是什么" class="headerlink" title="kafka是什么"></a>kafka是什么</h3><p>  kafka是一个分布式的消息队列,它具有高吞吐量、低延迟、高容错性等特点,可以用于处理大量的数据,并保证数据的可靠性。</p>
<h3 id="队列模型和kafka的消息模型"><a href="#队列模型和kafka的消息模型" class="headerlink" title="队列模型和kafka的消息模型"></a>队列模型和kafka的消息模型</h3><ul>
<li>队列模型<br>队列模型是一种常见的消息传递模型，它将消息存储在一个队列中，并使用消费者来消费这些消息。队列模型通常用于异步处理和广播消息。</li>
<li>kafka的消息模型<br>kafka的才写出模型使用发布订阅模型去解决这个问题,就比如我们使用主题作为消息通信载体,类似广播模式,发布者发布一条消息,改消息通过<br>主题传递给所有的订阅者,在一条消息广播之才订阅的用户时收不到该条消息的,如果只有一个订阅者,那么他的模型和队列模型时基本一样的</li>
</ul>
<h3 id="kafkfa核心概念"><a href="#kafkfa核心概念" class="headerlink" title="kafkfa核心概念"></a>kafkfa核心概念</h3><ul>
<li>producer<br>生产者是消息的发布者,它可以将消息发送到kafka的topic中</li>
<li>consumer<br>消费者是消息的订阅者,它可以从kafka的topic中消费消息</li>
<li>broker<br>broker是kafka的服务器,它负责存储消息和处理消费者的请求<br>  同时我们可以注意到,topic和partition</li>
<li>topic: producer将消息发送到特定的的主题,consumer可以从特定的主题中消费消息</li>
<li>partition: 属于topic的一部分,一个topic可以有多个partition,通俗的可以理解为一个消息队列中的队列</li>
</ul>
<h3 id="zookeeper在kafka中的作用"><a href="#zookeeper在kafka中的作用" class="headerlink" title="zookeeper在kafka中的作用"></a>zookeeper在kafka中的作用</h3><ul>
<li>broker注册<br>在zookeeper上会有一个专门用来进行broker进行broker服务器列表的节点,每个broker在启动时都会向该节点进行注册,从而将broker服务器列表进行更新</li>
<li>topic注册<br>在zookeeper上会有一个专门用来进行topic进行topic服务器列表的节点,每个topic在启动时都会向该节点进行注册,从而将topic服务器列表进行更新</li>
<li>负载均衡<br>当producer向kafka发送消息时,会根据topic找到对应的partition,并将消息发送到该partition所在的broker服务器上,从而实现负载均衡</li>
</ul>
<h3 id="kafkfa如何保证消息顺序-消息丢失和重复消费"><a href="#kafkfa如何保证消息顺序-消息丢失和重复消费" class="headerlink" title="kafkfa如何保证消息顺序,消息丢失和重复消费"></a>kafkfa如何保证消息顺序,消息丢失和重复消费</h3><ul>
<li>消息顺序<br>kafka只能保证在partition中的消息顺序,不能保证在topic中的消息顺序<br>  每次进行添加到partition时,都会才用尾加发,kafka只能保证在partition中的消息顺序,不能保证在topic中的消息顺序</li>
<li>消息丢失<br>kafka有三种常见丢失消息的情况<ul>
<li>生产者丢失消息<br>生产者丢失消息的原因可能是网络问题,或者producer在发送消息时发生了异常,从而导致消息丢失</li>
<li>消费者丢失消息的情况<br>在生产者给消费者消息的时候会给一个offset用来确认是否接受到消息,如果提交了offset后但是并没有接受到消息那么就会发生这种情况</li>
<li>kafka丢失消息<br>kafka丢失消息的原因可能是kafka服务器发生了异常,或者kafka服务器发生了重启,从而导致消息丢失</li>
</ul>
</li>
</ul>
<h3 id="kafka如何保证消息不重复消费"><a href="#kafka如何保证消息不重复消费" class="headerlink" title="kafka如何保证消息不重复消费"></a>kafka如何保证消息不重复消费</h3><pre><code>根本原因是消费者已经消费,但是没有提交offset
kafka侧由于服务端处理业务时间过长而导致了kafka认为服务假死
从而导致消费者重复消费
</code></pre>
<h3 id="消费失败会怎样"><a href="#消费失败会怎样" class="headerlink" title="消费失败会怎样"></a>消费失败会怎样</h3><pre><code>在默认情况下,当消费异常会进行重试,重试多次后会跳过当前消息,继续进行后序消息的消费
默认情况下会进行消费10次数
</code></pre>
<h2 id="业务思想"><a href="#业务思想" class="headerlink" title="业务思想"></a>业务思想</h2><p>好难啊啊啊啊</p>
<blockquote>
<ul>
<li>1. 首先使用构建增量索引作为广告检索服务</li>
<li>2. 使用mysql中的Master-Slave协议,通过slave监听binlog日志实现日志,达到数据一致性的目的</li>
<li>3. Kafka投递解析后的binlog日志，方便后续统计业务等，并维持索引（增量索引）。
<li>4. 检索广告的索引，实现条件匹配，并返回响应.
</ul>
</blockquote>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>SpringCloud 和 Dubbo的选择问题,zuul和Gateway的选择问题<br>  SpringCloud和Dubbo从原理上和思想几乎一样,由于Springcloud由于更加完善的微服务</li>
<li>Eureke中维护了Client中的哪些信息? 又怎样存储这些信息<br>  在其中注册了一个Instanceinfo实例,该实例中存储了Client的相关信息,如实例的id实例的ip地址,实例的端口号等</li>
<li>对数据表分层级的原因<br>  使用了逻辑分层</li>
</ol>
<ul>
<li>标识表与表之间的依赖关系,比如Level3依赖于Level2,值,可以避免了出现空指针的代码,使用了依赖关系可以进行逐层检查</li>
<li>表的逻辑分层可以简化了处理相同的业务逻辑的代码,比如Level2和Level3的表中都有相同的字段,那么我们可以将相同的字段进行提取,然后使用一个公共的类进行存储,从而简化代码</li>
</ul>
<ol start="4">
<li>为什么要把全量数据导出到文件中,而不是直接从数据库中加载<br>  首先导出到文件需要放在公共的文件系统中<br>  服务是多实例存在,同时操作数据库会造成巨大的压力</li>
<li>为什么广告数据要放在JVM内存中,如果太多放不下怎么办<br>  我们将数据放在了concurrentHashMap中,这样就放在了JVM内存中,考虑到了快的原因<br>  对于第二个问题,使用数据hash分区的策略,我们可以进行将数据时分散到不同的分区里面,每台机器只维护少量的源信息<br>  其次owomf可以使用redis缓存系统, 由于广告数据的数据不大,我们不考虑</li>
<li>Binlog是什么?如果监听的过程中,MySQL宕机了,再次启动服务,会是什么情况?<br>  Mysqlserver有四种类型的服务日志,error log,general query log,slow log,binlog<br>  其中binlog是用来记录数据库的变更的日志,可以用于数据恢复,数据同步等<br>  监听binlog有两种做法:</li>
</ol>
<ul>
<li>不添加任何配置,自动监听最新的日志</li>
<li>指定想要读取的binlog pos,记录指定位置的pos<br>  在每一次进行读取的时候我们只需要进行实时的记录每一次的postition就可以</li>
</ul>
<ol start="7">
<li>为什么选取Binlog作为增量数据的收集方案<br>  其实是可行的,我们可以通过Ribbon,feign等框架进行负载均衡,从而实现数据的同步<br>  问题是代码冗余,实现起来我们需要在实现的时候进行写一份代码,然后将数据进行同步过去,有可能导致数据不稳定<br>  检索系统需要知道数据表的定义,广告检索系统应该是不知道数据表的定义的<br>  投放系统与检索系统之间存在严重的耦合</li>
<li>为什么要把BinLog的增量数据发送到Kafka上,微服务再去订阅kafka的信息<br>  如果不使用kafka,那么我们就会导致一个问题那就是会导致所有的服务实例进行监听Mysql服务器,会导致数据库的压力<br>  检索系统可以进行订阅kafka进行订阅</li>
</ol>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>advertisement</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2024/03/09/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>RESTful 风格是一种设计风格，用于构建网络服务（Web Services），特别是在使用 HTTP 协议作为通信协议时。它遵循一组约定和原则，使得网络服务具有可伸缩性、可维护性、可扩展性以及性能良好的特性。</p>
<p>以下是 RESTful 风格的一些主要特点和原则：</p>
<ul>
<li><p>基于资源（Resource-Based）：RESTful 风格中的核心概念是资源（Resource），每个资源都有一个唯一的标识符（URI）来表示。客户端通过对资源的标识符进行操作来与资源进行交互，而不是直接对操作进行命名。</p>
</li>
<li><p>统一接口（Uniform Interface）：RESTful 风格使用统一的接口对资源进行操作。这包括使用 HTTP 动词（GET、POST、PUT、DELETE 等）对资源进行 CRUD 操作，以及使用标准的 HTTP 状态码来表示操作结果。</p>
</li>
<li><p>无状态（Stateless）：RESTful 风格的服务应该是无状态的，即服务端不会保存客户端的状态信息。每个请求应该包含足够的信息来完成该请求，服务端不会保存任何客户端的状态。</p>
</li>
<li><p>资源关系（Resource Relationships）：资源之间可以有关系，例如父子关系、引用关系等。在 RESTful 风格中，资源之间的关系通过 URI 来表示。</p>
</li>
<li><p>支持多种数据格式（Support for Different Data Formats）：RESTful 风格的服务应该支持多种数据格式，例如 JSON、XML 等，以便客户端可以根据自己的需求选择合适的数据格式。</p>
</li>
<li><p>可缓存性（Cacheability）：RESTful 风格的服务应该支持缓存机制，以提高性能和降低网络开销。服务端可以通过 HTTP 头部中的 Cache-Control 和 ETag 等字段来控制缓存。</p>
</li>
<li><p>总的来说，RESTful 风格的设计遵循了一系列的原则和约定，使得网络服务具有良好的可伸缩性、可维护性和可扩展性。通过遵循 RESTful 风格，开发者可以更容易地构建出高效、可靠、易于理解和维护的网络服务。</p>
</li>
</ul>
<h2 id="如何理解RestController"><a href="#如何理解RestController" class="headerlink" title="如何理解RestController"></a>如何理解RestController</h2><p>@RestController 是 Spring MVC 中的一个注解，它结合了 @Controller 和 @ResponseBody 注解的功能。</p>
<p>@Controller：@Controller 注解用于标识一个类是 Spring MVC 中的控制器（Controller）。Spring MVC 会将带有 @Controller 注解的类识别为控制器，并将其注册到 Spring 容器中。</p>
<p>@ResponseBody：@ResponseBody 注解用于将控制器方法的返回值直接作为 HTTP 响应体返回给客户端，而不是将其解析为视图（View）。通常，@ResponseBody 注解与返回 JSON、XML 或其他格式的数据结合使用，用于实现 RESTful 风格的接口。</p>
<p>因此，@RestController 注解的作用是将一个类标识为 RESTful 风格的控制器，并且其中的方法返回的结果直接作为 HTTP 响应的内容返回给客户端。在 Spring Boot 中，通常使用 @RestController 注解来定义 RESTful 风格的控制器，而不再需要额外使用 @ResponseBody 注解。这样可以减少代码的冗余，提高开发效率。</p>
<p>下面是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，HelloController 类被标记为 @RestController，而 hello() 方法被标记为 @GetMapping(“&#x2F;hello”)，该方法会处理对 “&#x2F;hello” 路径的 GET 请求，并将字符串 “Hello, World!” 作为响应体直接返回给客户端。</p>
<h1 id="SpringLearning"><a href="#SpringLearning" class="headerlink" title="SpringLearning"></a>SpringLearning</h1><h2 id="1-创建Spring项目"><a href="#1-创建Spring项目" class="headerlink" title="1. 创建Spring项目"></a>1. 创建Spring项目</h2><blockquote>前言: 解释一下什么是断言
在Java中，断言（Assertion）是一种用于测试程序内部逻辑是否正确的机制。断言允许程序员在代码中插入一些检查点，用于验证在程序执行过程中的一些假设是否成立。
如果假设不成立，断言会抛出一个 AssertionError 异常，从而提醒程序员代码中存在错误。
</blockquote>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 断言的语法如下</span></span><br><span class="line"><span class="keyword">assert</span> expression;</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line"><span class="keyword">assert</span> expression : message;</span><br><span class="line"><span class="comment">// 断言默认情况下是关闭的,想要启动断言可以:</span></span><br><span class="line">java -ea MyProgram</span><br></pre></td></tr></table></figure>
<p>  Spring的有点可以让我们仅仅关注应用代码的需求无需考虑如何满足框架的需求.</p>
<h2 id="开发WEB应用"><a href="#开发WEB应用" class="headerlink" title="开发WEB应用"></a>开发WEB应用</h2><h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><ol>
<li>构建领域类</li>
<li>创建控制器类  <p><ur>
  <li>控制器类的主要职责是处理HTTP请求</li>
  <li>要么将请求传递给试图以便于渲染HTML</li>
  <li>要么直接将数据写入RESTFUL</li></ur></p></li>
<li>设计视图<br>  进行使用Thymeleaf starter</li>
</ol>
<h3 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h3><p>  有@GetMapping和@PostMapping两种方式,区别?</p>
<ol>
<li>@GetMapping 用于处理GET请求</li>
<li>@PostMapping 用于处理POST请求</li>
<li>表单提交时，会自动将请求参数绑定到处理方法的参数上</li>
<li>处理方法返回一个视图名称，Thymeleaf会根据视图名称渲染出对应的HTML页面</li>
</ol>
<h2 id="使用数据"><a href="#使用数据" class="headerlink" title="使用数据"></a>使用数据</h2><h3 id="使用JDBC读取和写入数据"><a href="#使用JDBC读取和写入数据" class="headerlink" title="使用JDBC读取和写入数据"></a>使用JDBC读取和写入数据</h3><ol>
<li>创建数据访问对象(DAO)  <blockquote>使用Lombok注解可以在运行时生成访问器方法</blockquote></li>
</ol>
<h3 id="使用Spring-Data-JPA持久化数据"><a href="#使用Spring-Data-JPA持久化数据" class="headerlink" title="使用Spring Data JPA持久化数据"></a>使用Spring Data JPA持久化数据</h3><blockquote>
比较流行的Spring Data项目包括
<ur>
<li>SpringDataJpa: 基于关系型数据库进行Jpa持久化</li>
<li>SpringDataMongoDB:持久化到MongoDB</li>
<li>SpringDataNeo4j: 持久化到Neo4j图数据库</li>
<li>SpringDataRedis: 持久化到Redis key-value数据库</li>
<li>SpringDataCassandra: 持久化到Cassandra数据库</li>
</ur>
</blockquote>
CRUD操作: 创建读取更新删除

<h2 id="使用配置属性"><a href="#使用配置属性" class="headerlink" title="使用配置属性"></a>使用配置属性</h2><h3 id="细粒度的自动配置"><a href="#细粒度的自动配置" class="headerlink" title="细粒度的自动配置"></a>细粒度的自动配置</h3><ul>
<li>bean装配</li>
<li>属性注入</li>
</ul>
<h2 id="消费REST服务"><a href="#消费REST服务" class="headerlink" title="消费REST服务"></a>消费REST服务</h2><p>Spring应用可以使用多种方式来消费REST</p>
<ul>
<li>RestTemplate: Spring核心框架提供简单,同步REST客户端</li>
<li>WebClient: 响应式REST客户端,基于Project Reactor</li>
<li>Traverson: Spring提供的支持超链接同步的REST客户端</li>
</ul>
<h3 id="使用RestTemplate消费REST服务"><a href="#使用RestTemplate消费REST服务" class="headerlink" title="使用RestTemplate消费REST服务"></a>使用RestTemplate消费REST服务</h3><h3 id="使用WebClient消费REST服务"><a href="#使用WebClient消费REST服务" class="headerlink" title="使用WebClient消费REST服务"></a>使用WebClient消费REST服务</h3><h2 id="发送异步消息"><a href="#发送异步消息" class="headerlink" title="发送异步消息"></a>发送异步消息</h2><p>Spring提供的三种异步消息方案</p>
<ul>
<li>使用JMS</li>
<li>使用RabbitMQ</li>
<li>使用Kafka</li>
</ul>
<h3 id="使用Kafka的消息"><a href="#使用Kafka的消息" class="headerlink" title="使用Kafka的消息"></a>使用Kafka的消息</h3>]]></content>
      <categories>
        <category>techLearning</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly</title>
    <url>/2023/11/26/butterfly/</url>
    <content><![CDATA[<p>default</p>
<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>some note for the config for Hexo</p>
<ul>
<li>Inject<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.3.0以上支持</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如想添加額外的js&#x2F;css&#x2F;meta等等東西，可以在Inject裏添加，支持添加到head(</body>標籤之前)和bottom(</html>標籤之前)。</p>
<p>請注意：以標準的html格式添加內容</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  	- &lt;link rel=&quot;stylesheet&quot; href=&quot;/self.css&quot;&gt;</span><br><span class="line">  bottom:</span><br><span class="line">  	- &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>留意: 如果你的網站根目錄不是’&#x2F;‘,使用本地圖片時，需加上你的根目錄。<br>例如：網站是 <a href="https://yoursite.com/blog,%E5%BC%95%E7%94%A8css/xx.css%EF%BC%8C%E5%89%87%E8%A8%AD%E7%BD%AE%E7%82%BA">https://yoursite.com/blog,引用css/xx.css，則設置為</a><link rel="stylesheet" href="/blog/css/xx.css"></p>
<ul>
<li>CDN<br>配置文件中最後一部分CDN，裏面是主題所引用到的文件，可自行配置CDN。（非必要請勿修改，配置後請確認鏈接是否能訪問）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDN:</span><br><span class="line">  # The CDN provider of internal scripts (主題內部 js 的 cdn 配置)</span><br><span class="line">  # option: local/jsdelivr/unpkg/cdnjs/custom</span><br><span class="line">  # Dev version can only choose. ( dev版的主題只能設置為 local )</span><br><span class="line">  internal_provider: local</span><br><span class="line"></span><br><span class="line">  # The CDN provider of third party scripts (第三方 js 的 cdn 配置)</span><br><span class="line">  # option: local/jsdelivr/unpkg/cdnjs/custom</span><br><span class="line">  # when set it to local, you need to install hexo-butterfly-extjs</span><br><span class="line">  third_party_provider: jsdelivr</span><br><span class="line"></span><br><span class="line">  # Add version number to CDN, true or false  </span><br><span class="line">  version: false</span><br><span class="line"></span><br><span class="line">  # Custom format</span><br><span class="line">  # For example: https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125;</span><br><span class="line">  custom_format:</span><br><span class="line"></span><br><span class="line">  option:</span><br><span class="line">    # abcjs_basic_js:</span><br><span class="line">    # activate_power_mode:</span><br><span class="line">    # algolia_js:</span><br><span class="line">    # algolia_search:</span><br><span class="line">    # aplayer_css:</span><br><span class="line">    # aplayer_js:</span><br><span class="line">    # artalk_css:</span><br><span class="line">    # artalk_js:</span><br><span class="line">    # blueimp_md5:</span><br><span class="line">    # busuanzi:</span><br><span class="line">    # canvas_fluttering_ribbon:</span><br><span class="line">    # canvas_nest:</span><br><span class="line">    # canvas_ribbon:</span><br><span class="line">    # click_heart:</span><br><span class="line">    # ClickShowText:</span><br><span class="line">    # disqusjs:</span><br><span class="line">    # disqusjs_css:</span><br><span class="line">    # docsearch_css:</span><br><span class="line">    # docsearch_js:</span><br><span class="line">    # egjs_infinitegrid:</span><br><span class="line">    # fancybox:</span><br><span class="line">    # fancybox_css:</span><br><span class="line">    # fireworks:</span><br><span class="line">    # fontawesome:</span><br><span class="line">    # gitalk:</span><br><span class="line">    # gitalk_css:</span><br><span class="line">    # giscus:</span><br><span class="line">    # instantpage:</span><br><span class="line">    # instantsearch:</span><br><span class="line">    # katex:</span><br><span class="line">    # katex_copytex:</span><br><span class="line">    # lazyload:</span><br><span class="line">    # local_search:</span><br><span class="line">    # main:</span><br><span class="line">    # main_css:</span><br><span class="line">    # mathjax:</span><br><span class="line">    # medium_zoom:</span><br><span class="line">    # mermaid:</span><br><span class="line">    # meting_js:</span><br><span class="line">    # pangu:</span><br><span class="line">    # prismjs_autoloader:</span><br><span class="line">    # prismjs_js:</span><br><span class="line">    # prismjs_lineNumber_js:</span><br><span class="line">    # pjax:</span><br><span class="line">    # sharejs:</span><br><span class="line">    # sharejs_css:</span><br><span class="line">    # snackbar:</span><br><span class="line">    # snackbar_css:</span><br><span class="line">    # translate:</span><br><span class="line">    # twikoo:</span><br><span class="line">    # typed:</span><br><span class="line">    # utils:</span><br><span class="line">    # valine:</span><br><span class="line">    # waline_css:</span><br><span class="line">    # waline_js:</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>day10</title>
    <url>/2023/12/12/day10/</url>
    <content><![CDATA[<ul>
<li><p>java annotation<br><strong>元数据</strong>: </p>
<ol>
<li>描述数据的数据</li>
<li>描述程序的程序</li>
<li>描述类型的类型</li>
</ol>
<p><strong>元数据作用</strong>:</p>
<ol>
<li>编写文档</li>
<li>编译检查</li>
<li>代码分析</li>
</ol>
<p><strong>annotation</strong>:</p>
<ol>
<li>内建注解: </li>
<li>@Override<br><p1>用于告知编译器进行覆盖当前的类</p1></li>
<li>@Deprecated<br><p1>用于告知编译器进行不建议使用,因为已经过时了</p1></li>
<li>@SuppressWarnings<br><p1>忽视特定类型的错误</p1><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@SuppressWarnings(value=&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    ```  </span><br><span class="line">  <span class="number">4.</span> <span class="meta">@FunctionalInterface</span>  </span><br><span class="line">  &lt;p1&gt;用于告知编译器该接口只能有一个抽象方法&lt;/p1&gt;</span><br><span class="line">  &lt;/br&gt;</span><br><span class="line">  &lt;p&gt;以上的注解的主要的作用是为了完成代码的编译检查</span><br><span class="line"><span class="number">2.</span> 元annotation:</span><br><span class="line">  <span class="number">1.</span> <span class="meta">@Retention</span></span><br><span class="line">    &lt;p1&gt;表示该注解类型的注解保留的时长&lt;/p1&gt;</span><br><span class="line">    ```java</span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br></pre></td></tr></table></figure></li>
<li>@Target<br><p1>表示该注解类型可以应用在哪些地方,一个典型的原因是为了防止全局引用</p1><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br></pre></td></tr></table></figure></li>
<li>@Documented<br><p1>表示该注解是否可以出现在javadoc中</p1></li>
<li>@Inherited<br><p1>表示该注解是否可以被继承</p1></li>
<li>@Repeatable<br><p1>表示该注解是否可以重复使用</p1><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br></pre></td></tr></table></figure></li>
<li>自定义注解</li>
<li>定义注解<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotataion&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">website</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">revision</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JavaLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>day11</title>
    <url>/2024/01/12/day11/</url>
    <content><![CDATA[<p>时隔一个月的第一次写代码,闹麻了</p>
<span id="more"></span>
<h1 id="统计出现过一次的公共字符串"><a href="#统计出现过一次的公共字符串" class="headerlink" title="统计出现过一次的公共字符串"></a>统计出现过一次的公共字符串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWords</span><span class="params">(String[] words1, String[] words2)</span> &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();     <span class="comment">//依据hash中的value来判断是否重复</span></span><br><span class="line">        Map&lt;String,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String w : words1)&#123;</span><br><span class="line">            map1.put(w,map1.getOrDefault(w,<span class="number">0</span>)+<span class="number">1</span>);       <span class="comment">//如果已经存在,则value+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String w : words2)&#123;</span><br><span class="line">            map2.put(w,map2.getOrDefault(w,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String w: map1.keySet())&#123;                    <span class="comment">//使用ke&#x27;ySet来进行遍历</span></span><br><span class="line">            <span class="comment">//如果两个map中都存在且value为1,则说明只出现过一次</span></span><br><span class="line">            <span class="keyword">if</span>(map1.get(w)==<span class="number">1</span> &amp;&amp; map2.getOrDefault(w,<span class="number">0</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h1><p>给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numJewelsInStones</span><span class="params">(String jewels, String stones)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : jewels.toCharArray()) &#123;</span><br><span class="line">            map1.put(c, map1.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : stones.toCharArray()) &#123;</span><br><span class="line">            map2.put(c, map2.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : map1.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map2.containsKey(c)) &#123;</span><br><span class="line">                count += map2.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。比如abc和bca是字母异位词，它们可以出现在同一个答案中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将每一个字符串进行排序，然后作为key，将排序后的字符串作为value</span></span><br><span class="line">        <span class="comment">//将相同的字符串放到同一个list中</span></span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] ca = str.toCharArray();</span><br><span class="line">            Arrays.sort(ca);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(ca);</span><br><span class="line">            <span class="comment">//这里的key值每一个是排列好的标准</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希表的常用操作"><a href="#哈希表的常用操作" class="headerlink" title="哈希表的常用操作"></a>哈希表的常用操作</h1><p>在Java中，HashMap 是常用的哈希表实现，提供了一系列的操作来对哈希表进行管理。以下是一些常见的哈希表操作：</p>
<p>插入元素：</p>
<p>put(K key, V value): 将指定的键值对插入哈希表。<br>putAll(Map&lt;? extends K, ? extends V&gt; m): 将指定 Map 中的所有键值对插入哈希表。</p>
<p>获取元素：</p>
<p>get(Object key): 返回指定键对应的值。<br>getOrDefault(Object key, V defaultValue): 返回指定键对应的值，如果键不存在，则返回默认值。</p>
<p>删除元素：</p>
<p>remove(Object key): 删除指定键对应的键值对。<br>clear(): 清空哈希表中的所有键值对。</p>
<p>判断包含关系：</p>
<p>containsKey(Object key): 判断哈希表是否包含指定的键。<br>containsValue(Object value): 判断哈希表是否包含指定的值。</p>
<p>遍历操作：</p>
<p>keySet(): 返回包含所有键的 Set 集合。<br>values(): 返回包含所有值的 Collection 集合。<br>entrySet(): 返回包含所有键值对的 Set 集合。</p>
<p>其他操作：</p>
<p>size(): 返回哈希表中键值对的数量。<br>isEmpty(): 判断哈希表是否为空。<br>需要注意的是，哈希表的性能在很大程度上依赖于哈希函数的设计和负载因子的设置。在使用哈希表时，可以根据实际需求选择不同的操作来满足特定的场景。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>day12</title>
    <url>/2024/01/20/day12/</url>
    <content><![CDATA[<p>hahah, the first time to pass the hard difficulty problem.</p>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。    </p>
<p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums.length+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set1.contains(i))&#123;</span><br><span class="line">                temp = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最大子数组的和"><a href="#最大子数组的和" class="headerlink" title="最大子数组的和"></a>最大子数组的和</h1><p> 感觉貌似使用的算法叫贪心算法,设置一个max值,如果对于cur位上的数进行相加的时候大于max,那么max就等于cur上的数,否则max就等于max加上cur上的数,最后返回max即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">            sum = Math.max(sum, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h1><p>两道题可以使用无敌的hash来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map1 =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map1.put(num,map1.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : map1.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1.get(num)==<span class="number">1</span>)&#123;</span><br><span class="line">                temp = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            map1.put(num,map1.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:map1.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1.get(num)&gt;nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                temp = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><p>没啥说的,注意字符串转字符型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; nstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] ca = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ca) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                nstack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nstack.isEmpty() || nstack.pop() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nstack.isEmpty() || nstack.pop() != <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nstack.isEmpty() || nstack.pop() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nstack.isEmpty(); <span class="comment">// 检查是否还有未匹配的左括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除链表的中间节点"><a href="#删除链表的中间节点" class="headerlink" title="删除链表的中间节点"></a>删除链表的中间节点</h1><p>无敌的快慢指针,此题应该快指针从头开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteMiddle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; <span class="comment">// 修改这里</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != low)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = low.next;</span><br><span class="line">        low.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>HashMap</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>day13</title>
    <url>/2024/02/27/day13/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>卡了俩月的双指针,微笑</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义三个指针，保证遍历数组中的每一个结果</span></span><br><span class="line">    <span class="comment">//画图，解答</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//当前数组的长度为空，或者长度小于3时，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || len &lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//遍历数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//如果遍历的起始元素大于0，就直接退出</span></span><br><span class="line">            <span class="comment">//原因，此时数组为有序的数组，最小的数都大于0了，三数之和肯定大于0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重，当起始的值等于前一个元素，那么得到的结果将会和前一次相同</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i +<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当 l 不等于 r时就继续遍历</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="comment">//将三数进行相加</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="comment">//如果等于0，将结果对应的索引位置的值加入结果集中</span></span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 将三数的结果集加入到结果集中</span></span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                    <span class="comment">//在将左指针和右指针移动的时候，先对左右指针的值，进行判断</span></span><br><span class="line">                    <span class="comment">//如果重复，直接跳过。</span></span><br><span class="line">                    <span class="comment">//去重，因为 i 不变，当此时 l取的数的值与前一个数相同，所以不用在计算，直接跳</span></span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去重，因为 i不变，当此时 r 取的数的值与前一个相同，所以不用在计算</span></span><br><span class="line">                    <span class="keyword">while</span>(l&lt; r &amp;&amp; nums[r] == nums[r-<span class="number">1</span>])&#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//将 左指针右移，将右指针左移。</span></span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                    <span class="comment">//如果结果小于0，将左指针右移</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="comment">//如果结果大于0，将右指针左移</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="无重复的最长子串"><a href="#无重复的最长子串" class="headerlink" title="无重复的最长子串"></a>无重复的最长子串</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>这道题很巧妙的使用了滑动窗口<br>其中保持end端不断的前进,start通过动态的查找进行判断最长的字串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//start的位置保持变化,end的位置不变</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>,start = <span class="number">0</span>; end&lt;n ; end++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">alpha</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(alpha))&#123;</span><br><span class="line">                start = Math.max(map.get(alpha),start);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,end-start+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(end),end+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="找到字符串中所有的异位词"><a href="#找到字符串中所有的异位词" class="headerlink" title="找到字符串中所有的异位词"></a>找到字符串中所有的异位词</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查输入是否为空或 p 的长度大于 s 的长度</span></span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() || p.isEmpty() || p.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 返回空列表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取字符串 s 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> p.length(); <span class="comment">// 获取字符串 p 的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// 创建大小为 128 的数组，用于记录字符串 p 中每个字符的出现次数</span></span><br><span class="line">        <span class="comment">// 遍历字符串 p，统计每个字符的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; i++) &#123;</span><br><span class="line">            arr[p.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建结果列表</span></span><br><span class="line">        <span class="type">int</span>[] matchArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// 创建大小为 128 的数组，用于记录窗口内子串的字符出现次数</span></span><br><span class="line">        <span class="comment">// 遍历字符串 s，维护一个长度为 pLen 的窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            matchArr[s.charAt(i)]++; <span class="comment">// 添加窗口最右边的字符的出现次数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果窗口的长度大于等于 p 的长度</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= pLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 比较窗口内的字符出现次数数组和 p 的字符出现次数数组是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.equals(arr, matchArr)) &#123;</span><br><span class="line">                    <span class="comment">// 如果相等，将窗口的起始索引加入结果列表</span></span><br><span class="line">                    resultList.add((i + <span class="number">1</span>) - pLen);</span><br><span class="line">                &#125;</span><br><span class="line">                matchArr[s.charAt((i + <span class="number">1</span>) - pLen)]--; <span class="comment">// 移除窗口最左边的字符的出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultList; <span class="comment">// 返回结果列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h1><p>注意System.arraycopy()方法的用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            temp=(i+k)%nums.length;</span><br><span class="line">            ans[(i + k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(ans,<span class="number">0</span>,nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="除自身以外的整数积"><a href="#除自身以外的整数积" class="headerlink" title="除自身以外的整数积"></a>除自身以外的整数积</h1><p>使用从左边遍历一遍,从右边遍历一遍,然后进行求积</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] l = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        l[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        r[n-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            l[i]=l[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            r[i]=r[i+<span class="number">1</span>]*nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[i]=r[i]*l[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h1><p>通过设置两个标记位数组,第一遍遍历进行设置,第二遍遍历进行置零</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> [] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        <span class="type">boolean</span> [] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    row[i]=<span class="literal">true</span>;</span><br><span class="line">                    col[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[i]==<span class="literal">true</span>||col[j]==<span class="literal">true</span>)&#123;</span><br><span class="line">                    matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>double pointer</tag>
        <tag>sliding</tag>
        <tag>window</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>day14</title>
    <url>/2024/03/06/day14/</url>
    <content><![CDATA[<h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><p>很简单的一道题,按理来说应该给easy,无奈想不到单指针,进行两次遍历,进行交换元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[tag];</span><br><span class="line">                nums[tag] = temp;</span><br><span class="line">                tag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tag2</span> <span class="operator">=</span> tag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tag; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                    nums[i] = nums[tag2];</span><br><span class="line">                    nums[tag2] = temp;</span><br><span class="line">                    tag2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p>很抽象的一提,微笑,先从最右边开始,找到第一个左边小于右边的数,然后从最右边开始,找到第一个大于这个数的数,然后交换这两个数,最后将这个数后面的数进行翻转,因为后面的数是降序的,所以翻转后就是最小的排列了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 从右往左找到第一个递增的位置</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; nums[k] &gt;= nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果k &lt; 0，说明整个序列是降序的，直接反转即可</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左找到第一个比nums[k]大的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; k &amp;&amp; nums[l] &lt;= nums[k]) &#123;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换nums[k]和nums[l]</span></span><br><span class="line">        swap(nums, k, l);</span><br><span class="line">        <span class="comment">// 反转nums[k+1]到nums[nums.length-1]</span></span><br><span class="line">        reverse(nums, k + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转数组中一段元素的顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            swap(nums, start, end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>形象的去想,进行对于四个顶点去卡着,遍历有点想法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span> , below = matrix.length-<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i&lt;right; i++)&#123;</span><br><span class="line">                ans.add(asList(matrix[top][i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++top&gt;below) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i&lt;below; i++)&#123;</span><br><span class="line">                ans.add(asList(matrix[i][right]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++top&gt;below) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i&gt;left; i++)&#123;</span><br><span class="line">                ans.add(asList(matrix[below][i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;--below) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> below; i&gt;top; i++)&#123;</span><br><span class="line">                ans.add(asList(matrix[i][left]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(++left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>day2</title>
    <url>/2023/11/28/day2/</url>
    <content><![CDATA[<ul>
<li>两个链表求和的问题</br><br>如果两个链表长度不同，那么短的链表在求和的时候，需要补0。</br><br>如果两个链表长度相同，那么就比较每一位，相加，如果大于9，则进位，否则不进位。</br><br>这里我们的想法是申请一个新的链表,如果两个链表长度不同，那么短的链表在求和的时候，需要补0。</br><br>如果两个链表长度相同，那么就比较每一位，相加，如果大于9，则进位，否则不进位。</br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> l2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carrier</span> <span class="operator">=</span> <span class="number">0</span> ; <span class="comment">//进位</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;    <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">null</span> || p2!=<span class="literal">null</span>||carrier!=<span class="number">0</span>)&#123;<span class="comment">//一种极端的情况是如果两个链表都已经为空,这时候我们需要判断carrier是否为0</span></span><br><span class="line">            <span class="comment">//这里不能使用cur.val域</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (p1 != <span class="literal">null</span>?p1.val:<span class="number">0</span>) + (p2 != <span class="literal">null</span>?p2.val:<span class="number">0</span>) + carrier;</span><br><span class="line">            carrier = sum /<span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digital</span> <span class="operator">=</span> sum%<span class="number">10</span>; <span class="comment">//ListNode使用当前的值来一会进行申请新的值</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(digital);</span><br><span class="line">            <span class="comment">//为了能够使得链表继续往下走我们需要判断会进行延长链表</span></span><br><span class="line">            <span class="keyword">if</span>(p1!=<span class="literal">null</span>) p1 = p1.next;</span><br><span class="line">            <span class="keyword">if</span>(p2!=<span class="literal">null</span>) p2 = p2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p1><b>记得预设pre节点,方便从头遍历</b></p1></br></li>
<li>删除链表的倒数第N个节点</br><br><p1>最初的想法是使用一个反转链表,在正序的基础上进行删除链表,但是在删除链表的时候我们首先要进行考虑的是不能破坏链表的原本结构</p1><br><p1>这时候我们的通用的想法是新增一个新的链表来进行表示</p1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> reverse(head);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
在这里我们可以进行设置两个指针,其中的一个指针用来寻找位置,另外的一个指针用来删除其中的节点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> reverse(head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 创建一个虚拟节点，方便处理头节点的情况</span></span><br><span class="line">        dummy.next = p1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> dummy; <span class="comment">// p2是p1的前驱节点</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == n)&#123;</span><br><span class="line">                p2.next = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            p2 = p1; <span class="comment">// 更新p2</span></span><br><span class="line">            p1 = p1.next; <span class="comment">// 更新p1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(dummy.next); <span class="comment">// 反转回来，返回删除了倒数第n个节点的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// 返回反转后的链表的头节点</span></span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>day3</title>
    <url>/2023/12/02/day3/</url>
    <content><![CDATA[<ul>
<li><p>两两交换链表中的节点</br><br><p1>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p1></p>
<ul>
<li>递归<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空或者只有一个节点，无需交换</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">one</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">two</span> <span class="operator">=</span> one.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">three</span> <span class="operator">=</span> two.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换节点</span></span><br><span class="line">        two.next = one;</span><br><span class="line">        one.next = swapPairs(three);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> two;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  * 迭代</span><br><span class="line">  ```java</span><br><span class="line">  &lt;p1&gt;很奇妙的一种写法,给每一个节点都抽象化成数字&lt;/p1&gt;</span><br><span class="line">  ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">          <span class="comment">// 如果链表为空或者只有一个节点，无需交换</span></span><br><span class="line">          <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">          dummy.next = head;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="type">ListNode</span> <span class="variable">one</span> <span class="operator">=</span> pre.next;</span><br><span class="line">              <span class="type">ListNode</span> <span class="variable">two</span> <span class="operator">=</span> one.next;</span><br><span class="line">              <span class="type">ListNode</span> <span class="variable">three</span> <span class="operator">=</span> two.next;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 交换节点</span></span><br><span class="line">              one.next = three;</span><br><span class="line">              two.next = one;</span><br><span class="line">              pre.next = two;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 更新 pre 指针</span></span><br><span class="line">              pre = one;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> dummy.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>反转二叉树</p>
<ul>
<li>递归 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">	root.right = root.left;</span><br><span class="line">	root.left = tmp;</span><br><span class="line">	<span class="comment">//递归交换当前节点的 左子树</span></span><br><span class="line">	invertTree(root.left);</span><br><span class="line">	<span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">	invertTree(root.right);</span><br><span class="line">	<span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line">	<span class="comment">//都已经交换完了</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binarytree</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>day4</title>
    <url>/2023/12/02/day4/</url>
    <content><![CDATA[<ul>
<li>盛水最多的容器  <p>
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
</p>
本题的做法十分巧妙,从最两侧的开始寻找最大值,然后向中间靠拢,每次都更新最大值,直到相遇  
其中如果两侧的值相等,则向中间靠拢,因为如果向中间靠拢,则可以利用左侧的值,而右侧的值已经用不  
如果两侧的较低的那个,我们就可以进行选择不要,向中间靠拢
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">back</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            min = height[pre]&lt;height[back]?height[pre]:height[back];</span><br><span class="line">            ans[i] = min*(back-pre);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(height[pre]&lt;height[back])</span><br><span class="line">                pre++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                back--;</span><br><span class="line">            <span class="keyword">if</span>(i==height.length)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化最大值为数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> ans[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，找到最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; ans.length; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[k] &gt; max) &#123;</span><br><span class="line">                max = ans[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>day5</title>
    <url>/2023/12/04/day5/</url>
    <content><![CDATA[<ul>
<li><p>求一棵树的最大深度</p>
<ul>
<li><p>深度优先遍历</br><br>对于左子树和右子树进行递归,如果哪个值比较大,我们就可以进行保存,值得注意的是,我们应该将这一轮的值进行保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> leftHeight=maxDepth(root.left);</span><br><span class="line">      <span class="type">int</span> rightHeight=maxDepth(root.right);</span><br><span class="line">      <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>正统dfs想法和我第一遍想的一样,写不出来hhhhh<br>其中极端情况去想这个递归的是,我们只有一颗全部是左子树的树,这时候我们就要不停的向左走,如果走到头我们就要进行回退进行判断</br><br>另外,如果只有一个节点的,我们就想要进行判断是否是叶子节点,这时候我们期望的是返回节点,进行判断父节点是否有兄弟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      traverse(root);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      height ++;</span><br><span class="line">      ans = Math.max(ans,height);</span><br><span class="line">      traverse(root.left);</span><br><span class="line">      traverse(root.right);</span><br><span class="line">      height--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>层序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      List&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(),temp;<span class="comment">//注意声明</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span>(TreeNode treeNode : queue)&#123;</span><br><span class="line">              <span class="keyword">if</span>(treeNode.left!=<span class="literal">null</span>)</span><br><span class="line">                  temp.add(treeNode.left);</span><br><span class="line">              <span class="keyword">if</span>(treeNode.right!=<span class="literal">null</span>)</span><br><span class="line">                  temp.add(treeNode.right); </span><br><span class="line">          &#125;</span><br><span class="line">          queue = temp;</span><br><span class="line">          ans++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对称二叉树  </p>
<ul>
<li>使用栈完成,思想和递归类似,但是脑子想不清楚,fufufufuffuf  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LinkedList&lt;TreeNode&gt; nstack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      nstack.push(root.left);</span><br><span class="line">      nstack.push(root.right);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!nstack.isEmpty()) &#123;</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> nstack.pop();</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> nstack.pop();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (right == <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (right == <span class="literal">null</span> || left == <span class="literal">null</span> || right.val != left.val) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 对称位置的节点入栈，注意入栈顺序</span></span><br><span class="line">          nstack.push(left.left);</span><br><span class="line">          nstack.push(right.right);</span><br><span class="line">          nstack.push(left.right);</span><br><span class="line">          nstack.push(right.left);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>每次看了递归只能喵喵喵的叫,<bold>1.</bold>添加跳出循环的条件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isSymmetric(root, root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode node1, TreeNode node2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span> || node1.val != node2.val) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> isSymmetric(node1.left, node2.right) &amp;&amp; isSymmetric(node1.right, node2.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>总结一下:</strong><br>使用 ArrayList 实现队列和栈队列操作：<br>加入元素： 使用 add 方法将元素添加到 ArrayList 的末尾。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line">ArrayList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">queue.add(element);</span><br></pre></td></tr></table></figure>
<p>删除元素： 使用 remove(0) 方法移除第一个元素。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">removedElement</span> <span class="operator">=</span> queue.remove(<span class="number">0</span>);</span><br><span class="line">栈操作：</span><br></pre></td></tr></table></figure>
<p>加入元素： 使用 add 方法将元素添加到 ArrayList 的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line">ArrayList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stack.add(element);</span><br></pre></td></tr></table></figure>
<p>删除元素： 使用 remove(size - 1) 方法移除最后一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">removedElement</span> <span class="operator">=</span> stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">使用 LinkedList 实现队列和栈</span><br></pre></td></tr></table></figure>
<p>队列操作：<br>加入元素： 使用 offer 方法将元素添加到 LinkedList 的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line">LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(element);</span><br></pre></td></tr></table></figure>
<p>删除元素： 使用 poll 方法移除并返回第一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">removedElement</span> <span class="operator">=</span> queue.poll();</span><br></pre></td></tr></table></figure>
<p>栈操作：<br>加入元素： 使用 addFirst 或 push 方法将元素添加到 LinkedList 的开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">stack.addFirst(element);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">stack.push(element);</span><br></pre></td></tr></table></figure>
<p>删除元素： 使用 removeFirst 或 pop 方法移除并返回第一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">removedElement</span> <span class="operator">=</span> stack.removeFirst();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">poppedElement</span> <span class="operator">=</span> stack.pop();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binarytree</tag>
      </tags>
  </entry>
  <entry>
    <title>day8</title>
    <url>/2023/12/06/day8/</url>
    <content><![CDATA[<ul>
<li>中序遍历<br>…..写了这么久还是写不对,累qwq<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 修改为 Stack&lt;TreeNode&gt; 类型   一个栈进行操作</span></span><br><span class="line">      List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();      <span class="comment">//一个linkedlist进行记录</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">              stack.push(root);</span><br><span class="line">              root = root.left;</span><br><span class="line">          &#125;</span><br><span class="line">          root = stack.pop();</span><br><span class="line">          result.add(root.val);</span><br><span class="line">          root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第k小的元素在二叉搜索树中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 修改为 Stack&lt;TreeNode&gt; 类型</span></span><br><span class="line">      List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">              stack.push(root);</span><br><span class="line">              root = root.left;</span><br><span class="line">          &#125;</span><br><span class="line">          root = stack.pop();</span><br><span class="line">          result.add(root.val);</span><br><span class="line">          root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result.get(k-<span class="number">1</span>);           <span class="comment">//LinkedList 直接用get方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binarytree</tag>
      </tags>
  </entry>
  <entry>
    <title>day6</title>
    <url>/2023/12/04/day6/</url>
    <content><![CDATA[<p>default</p>
<ul>
<li>二叉树的直径<ul>
<li>递归<br>递归一想就不会, 二想还不会:)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      traverse(root);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> traverse(node.left);</span><br><span class="line">      <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> traverse(node.right);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update the diameter if the sum of left and right depths is greater than current ans</span></span><br><span class="line">      ans = Math.max(ans, leftDepth + rightDepth);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Return the depth of the current subtree rooted at &#x27;node&#x27;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>将有序数列转换为平衡高度二叉树<ul>
<li>递归  查找中间的数字, 左边递归, 右边递归<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> traverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">traverse</span><span class="params">(<span class="type">int</span> num[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123; <span class="comment">//!!!!看返回值,构造参数!!!</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num[mid]);</span><br><span class="line">      ans.left = traverse(num,left,mid-<span class="number">1</span>);</span><br><span class="line">      ans.right = traverse(num,mid+<span class="number">1</span>,right);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binarytree</tag>
      </tags>
  </entry>
  <entry>
    <title>day9</title>
    <url>/2023/12/12/day9/</url>
    <content><![CDATA[<ul>
<li>两数之和<br>已知两个数,判断是否在hash中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; narr = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();    <span class="comment">//</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(narr.containsKey(target-nums[i]))&#123;                      <span class="comment">//**containsKey**() 判断hash中是否有key</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;narr.get(target-nums[i]),i&#125;; </span><br><span class="line">          &#125;</span><br><span class="line">      narr.put(nums[i],i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>sqlStudy</title>
    <url>/2024/03/20/sqlStudy/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="什么是Master-Slave协议"><a href="#什么是Master-Slave协议" class="headerlink" title="什么是Master-Slave协议?"></a>什么是Master-Slave协议?</h2><p>MySQL的复制（replication）功能是支持主从复制的，主从复制是指将主数据库的DDL和DML操作通过二进制日志（binary log）传到从数据库上，然后在从数据库上对这些日志重新执行（也叫重做），从而使得从数据库的数据与主数据库的数据保持一致。</p>
<blockquote>
下面是 MySQL Master-Slave 复制的基本工作流程：

<p>主服务器记录数据更改：当主服务器上的数据库发生数据更改（如插入、更新、删除操作）时，MySQL 会将这些更改记录到二进制日志（binlog）中。</p>
<p>从服务器连接主服务器：从服务器通过与主服务器建立连接，并发送一个请求，告知主服务器它要开始复制数据了。</p>
<p>主服务器发送数据：一旦从服务器与主服务器建立了连接并发送了复制请求，主服务器会将自己的二进制日志文件传送给从服务器。</p>
<p>从服务器应用数据更改：从服务器接收到主服务器的二进制日志后，会将其中的数据更改逐条应用到自己的数据库中，从而使得自己的数据与主服务器保持同步。</p>
<p>MySQL 的 Master-Slave 复制协议具有以下特点和优势：</p>
<p>高可用性和容错性：通过将数据复制到多个从服务器上，可以实现数据的冗余备份和故障转移，从而提高了系统的可用性和容错性。<br>读写分离：通过将读操作分发到从服务器上，可以减轻主服务器的负载，提高系统的读取性能。<br>数据分发：可以将不同地区或不同业务场景的数据分发到不同的从服务器上，实现数据的局部化存储和访问。<br>灾备和备份：从服务器可以用作主服务器的灾备和备份，一旦主服务器发生故障，可以快速切换到从服务器上提供服务，从而保证系统的持续运行。<br>总的来说，MySQL 的 Master-Slave 复制协议是一种重要的数据库复制技术，可以帮助实现数据的同步备份、读写分离、灾备和备份等功能，提高了数据库系统的可用性、性能和可靠性。</p>
</blockquote>]]></content>
      <categories>
        <category>techLearning</category>
      </categories>
  </entry>
  <entry>
    <title>systemSafeTheory</title>
    <url>/2023/11/26/systemSafeTheory/</url>
    <content><![CDATA[<h1 id="基于-net框架下的长数据流的对称加密解密通信"><a href="#基于-net框架下的长数据流的对称加密解密通信" class="headerlink" title="基于.net框架下的长数据流的对称加密解密通信"></a>基于.net框架下的长数据流的对称加密解密通信</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><h3 id="1-1实验目的："><a href="#1-1实验目的：" class="headerlink" title="1.1实验目的："></a>1.1实验目的：</h3><p>本实验的研究目的是基于.net框架下使用CBC加密算法使用C#实现对于TCP的保密通信服务,通过对于《网络安全与密码编码学》第6章和第5章提到的算法进行实现，将对TCP或UDP的通信进行加密处理，以提供保密性。</p>
<h3 id="1-2问题陈述"><a href="#1-2问题陈述" class="headerlink" title="1.2问题陈述"></a>1.2问题陈述</h3><p>在实现对TCP通信的保密服务时,目标解决以下的问题</p>
<ol>
<li>选择加密算法, 从CBC、CFB和OFB中选择一种合适的算法，用于对通信数据进行加密。这个选择应该基于算法的安全性和适用性。</li>
<li>实现加密算法：将选定的加密算法以代码形式实现，以便能够对TCP或UDP通信数据进行加密处理。</li>
<li>保密服务封装：封装TCP或UDP的网络&#x2F;0函数（如socket对象的read&#x2F;write或recvfrom&#x2F;sendto），以提供具有保密处理的新函数（如sec read&#x2F;sec write或sec recvfrom&#x2F;sec sendto）。这些新函数应该在数据传输之前对数据进行加密，在数据接收后对数据进行解密。</li>
<li>效率和延迟：研究需要考虑加密和解密过程对数据传输的影响。确保实现的加密服务在保证通信安全的同时，保持合理的性能，避免对通信速度和延迟产生过大的负面影响。</li>
<li>安全性评估：对实现的保密服务进行安全性评估，包括对可能的攻击进行分析和测试。确保所提供的保密服务能够有效防护敏感数据免受未经授权的访问和窃取。</li>
</ol>
<h2 id="2-研究方法"><a href="#2-研究方法" class="headerlink" title="2.研究方法"></a>2.研究方法</h2><h3 id="2-1选择加密算法和工具"><a href="#2-1选择加密算法和工具" class="headerlink" title="2.1选择加密算法和工具"></a>2.1选择加密算法和工具</h3><p>  在实验的过程中选择了CBC链式加密模式,AES块密码算法,CBC模式可以与各种块密码算法结合使用，如AES（Advanced Encryption Standard）、DES（Data Encryption Standard）等。这些块密码算法已经经过广泛研究和分析，被广泛应用于安全通信和数据保护领域。<br>  CBC加密算法是为了提供对TCP或UDP通信的保密服务，以确保数据的保密性和完整性。通过CBC模式的特性和与块密码算法的适配，我们可以实现对数据流的加密，使其在传输过程中对未经授权的访问者具有高度的安全性。</p>
<h3 id="2-2实现加密服务的算法细节"><a href="#2-2实现加密服务的算法细节" class="headerlink" title="2.2实现加密服务的算法细节"></a>2.2实现加密服务的算法细节</h3><p>  .net框架下提供了对于高级加密(AES)的抽象类<br>  在对于<strong>System.Security.Cryptography</strong>的命名空间下提供了对于加密服务（包括数据安全编码和解码）以及其他许多操作（如哈希、随机数生成和消息验证）<br>6. AES算法细节:</p>
<p><img src="/ga-hexo%5Csource_drafts%5CsystemSafeTheory%5Cassets%5CAES.jpg" alt="系统安全理论上机报告AESjpg"></p>
<ol>
<li>加密函数</li>
</ol>
<ul>
<li>创建AesManaged对象：使用了AesManaged类创建一个AES算法的实例。</li>
<li>设置 设置密钥和初始向量：设置aes.Key和aes.IV为提供的密钥（key）和初始向量（iv）</li>
<li>创建加密器（encryptor）：使用CreateEncryptor方法创建一个用于加密的ICryptoTransform对象。</li>
<li>创建内存流（MemoryStream）：创建一个内存流（memoryStream）用于存储加密后的数据。</li>
<li>创建加密流（CryptoStream）：使用CryptoStream类创建一个加密流（cryptoStream），将其与内存流和加密器关联。</li>
<li>将明文进行加密：将明文（plainText）转换为字节数组（plainBytes），然后通过加密流将加密后的数据写入内存流。</li>
<li>返回加密后的结果：将内存流转换为字节数组并返回。</li>
</ul>
<p><img src="/ga-hexo%5Csource_drafts%5CsystemSafeTheory%5Cassets%5C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%BA%E6%8A%A5%E5%91%8A-AESDecryption.png" alt="系统安全理论上机报告AESDecryptionpng"></p>
<ol start="2">
<li>解密函数</li>
</ol>
<ul>
<li>创建AesManaged对象：同样使用AesManaged类创建一个AES算法的实例。</li>
<li>设置密钥和初始向量：设置aes.Key和aes.IV为提供的密钥（key）和初始向量（iv）。</li>
<li>创建解密器（decryptor）：使用CreateDecryptor方法创建一个用于解密的ICryptoTransform对象。</li>
<li>创建内存流（MemoryStream）：使用密文（cipherText）创建一个内存流（memoryStream）。</li>
<li>创建解密流（CryptoStream）：使用CryptoStream类创建一个解密流（cryptoStream），将其与内存流和解密器关联。</li>
<li>创建StreamReader：使用StreamReader类读取解密流中的数据。</li>
</ul>
<ol start="2">
<li><p>算法改进:</p>
</li>
<li><p>随机数生成：在加密过程中，随机数的生成是至关重要的。使用安全的随机数生成器来生成初始向量（IV）和其他随机数，以确保加密的随机性。<br>  private static byte[] GenerateRandomBytes(int length)：添加了一个辅助方法，用于生成指定长度的随机字节数组。这个方法使用RNGCryptoServiceProvider类生成高质量的随机字节。</p>
</li>
</ol>
<p>  <img src="/ga-hexo%5Csource_drafts%5CsystemSafeTheory%5Cassets%5C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%BA%E6%8A%A5%E5%91%8A-generatorRandom.png" alt="系统安全理论上机报告generatorRandompng"></p>
<ol start="4">
<li><p>aes.Padding &#x3D; PaddingMode.PKCS7;：在加密和解密方法中，设置填充方案为PKCS7确保明文数据的长度与加密算法的块大小对齐。填充方案：在加密过程中，考虑采用适当的填充方案，以确保明文数据长度与加密算法块大小对齐。常见的填充方案包括PKCS7和ISO&#x2F;IEC 7816-4。</p>
</li>
<li><p>异常处理和错误检查：加密过程中可能出现各种异常情况，如无效的密钥、无效的密文等。应该对这些异常情况进行适当的处理和错误检查，以确保系统的稳定性和安全性。添加了try-catch块：在Main方法中，添加了异常处理的代码，以捕获可能发生的异常并打印错误消息。</p>
</li>
</ol>
<p>  <img src="/ga-hexo%5Csource_drafts%5CsystemSafeTheory%5Cassets%5C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%BA%E6%8A%A5%E5%91%8A-errorCheck.png" alt="系统安全理论上机报告errorCheckpng"></p>
<p>生成打包方案:<img src="/ga-hexo%5Csource_drafts%5CsystemSafeTheory%5Cassets%5C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%BA%E6%8A%A5%E5%91%8A-AESdll.png" alt="系统安全理论上机报告AESdllpng"></p>
<ol start="3">
<li>CBC算法实现<img src="D:\Hexo\ga-hexo\source_drafts\systemSafeTheory\assets\系统安全理论上机报告-paddingError.png" alt="系统安全理论上机报告CBCImplementpng"></li>
</ol>
<ul>
<li>密钥和初始向量（IV）：密钥（EncryptionKey）以UTF-8编码转换为字节数组，并用于设置AES算法的密钥。<br>初始向量（iv）是在加密和解密过程中使用的随机向量，用于增加加密算法的随机性和安全性。</li>
<li>加密方法（Encrypt）将明文字符串转换为UTF-8编码的字节数组，并使用AES算法和CBC模式创建加密器（encryptor）。</li>
<li>加密器将数据写入到CryptoStream流中，实现数据的加密操作。</li>
<li>解密方法（Decrypt）将密文字节数组传入，并使用AES算法和CBC模式创建解密器（decryptor）。</li>
<li>解密器将数据从CryptoStream流中读取，并使用StreamReader将解密后的数据转换为明文字符串。</li>
<li>CBC模式（Cipher Block Chaining）将每个分组的密文与前一个分组的密文进行异或运算，增加了加密算法的安全性。</li>
<li>PKCS7填充（Padding Mode）被用于确保明文数据与加密算法块大小对齐，以满足分组加密的要求。</li>
</ul>
<ol start="4">
<li><p>TCP server and client代码实现<br>  将上述的CBC代码已经打包成了dll文件进行tcp的代码实现</p>
</li>
<li><p>TCPserver代码实现<br>  <img src="file://D:\Atom\systemsafe\assets\系统安全理论上机报告-TCPserver.png?msec=1700966577482" alt="系统安全理论上机报告TCPserverpng"></p>
</li>
</ol>
<ul>
<li>创建 TCP 客户端实例：使用 TcpClient 类创建 TCP 客户端实例。可以通过指定服务器的 IP 地址和端口号来建立与服务器的连接。</li>
<li>连接服务器：使用 TcpClient 实例的 Connect 方法连接到服务器。提供服务器的 IP 地址和端口号作为参数。</li>
<li>发送数据：通过获取与服务器建立的连接后的网络流，使用流的 Write 方法发送数据到服务器。可以将要发送的数据转换为字节数组后发送。</li>
<li>接收数据：使用网络流的 Read 方法从服务器接收数据。可以指定一个缓冲区来存储接收到的数据，并根据需要进行解码。</li>
<li>System.Net.Sockets: 这个命名空间提供了与网络通信相关的类和方法。其中的 TcpClient 类用于创建 TCP 客户端实例，NetworkStream 类用于获取网络流进行数据传输。<br>###2.3 对于secwriter的自定义封装实现<br>&lt; src&#x3D;”assets&#x2F;系统安全理论上机报告-secWriter封装.png” width&#x3D;”” height&#x3D;”” &gt;<br><em><strong>封装 StreamReader 和 StreamWriter 类时，创建了自定义的 SecReader 和 SecWriter 类，用于在网络输入输出过程中提供保密处理。这两个类在构造函数中接受 NetworkStream 和 ICryptoTransform 对象作为参数。</strong></em></li>
<li>SecReader 类的构造函数接收一个 NetworkStream 对象和一个用于解密的 ICryptoTransform 对象。</li>
<li>在 SecReader 类内部，我们创建一个 StreamReader 对象，并将其构造函数参数设置为一个 CryptoStream 对象，该 CryptoStream 对象使用传入的 NetworkStream 和解密器 ICryptoTransform 对象。</li>
<li>SecReader 类中的 ReadLine 方法简单地调用内部 StreamReader 对象的 ReadLine 方法来读取解密后的数据，并返回读取的字符串。<br>对于</li>
</ul>
<h2 id="3-安全性评估和攻击模型"><a href="#3-安全性评估和攻击模型" class="headerlink" title="3.安全性评估和攻击模型"></a>3.安全性评估和攻击模型</h2><h3 id="3-1对于CBC模式的安全性评估"><a href="#3-1对于CBC模式的安全性评估" class="headerlink" title="3.1对于CBC模式的安全性评估"></a>3.1对于CBC模式的安全性评估</h3><ul>
<li><p>常见的误差传播：如果在传输或存储过程中发生了一个比特的错误，该错误将会在解密过程中影响整个密文块的解密，进而导致明文块的完全不可预测的改变。这被称为误差传播。由于每个密文块都依赖于前一个密文块，一个误差的传播可能导致整个消息的损坏。</p>
</li>
<li><p>不适合并行处理：由于每个密文块的加密都依赖于前一个密文块的解密结果，因此无法对多个密文块进行并行加密。这限制了 CBC 模式在并行处理环境下的效率。</p>
</li>
<li><p>不支持随机访问：由于每个密文块的解密都依赖于前一个密文块的解密结果，因此无法直接访问和解密消息中的任意块。必须按顺序解密整个消息。</p>
</li>
<li><p>对初始向量（IV）的要求：CBC 模式要求使用随机和唯一的初始向量（IV）作为第一个密文块的输入。如果 IV 的生成不够随机或者在不同消息间重复使用，可能会导致安全性问题。</p>
<h3 id="3-2可能的攻击方式"><a href="#3-2可能的攻击方式" class="headerlink" title="3.2可能的攻击方式"></a>3.2可能的攻击方式</h3></li>
</ul>
<ol>
<li>重放攻击（Replay Attack）：攻击者截获并记录了加密的消息块，然后在稍后的时间重新发送这些消息块，以试图欺骗接收方。由于CBC模式下每个密文块都依赖于前一个密文块，因此重放攻击可能会导致解密的结果与原始消息不同。</li>
<li>选择明文攻击（Known Plaintext Attack）：攻击者可以通过观察和记录明文和对应的密文块对，来尝试分析加密算法和密钥。在CBC模式下，攻击者可能通过修改明文块并观察密文块的变化，以获取有关密钥或明文的信息。</li>
<li>填充攻击（Padding Oracle Attack）：填充攻击是一种侧信道攻击，利用对密文的填充错误的响应来推断明文的信息。攻击者可能通过发送特定的恶意数据并观察服务器的响应来获取关于密钥或明文的信息。</li>
<li>位翻转攻击（Bit Flipping Attack）：攻击者可能通过修改密文块中的某些位来影响解密过程，并试图更改解密后的明文内容。由于CBC模式下密文块的解密依赖于前一个密文块，对密文块中的位进行修改可能会导致解密结果的不可预测性。</li>
</ol>
<h3 id="3-3预期的解决方式"><a href="#3-3预期的解决方式" class="headerlink" title="3.3预期的解决方式"></a>3.3预期的解决方式</h3><p>  这些攻击方式都是针对CBC模式的特定漏洞和弱点而设计的。为了防范这些攻击，可以采取一系列的安全措施，包括使用消息认证码（MAC）来确保数据完整性和身份验证、使用随机和唯一的初始向量（IV）、定期更换密钥、对密文进行完整性检查等。此外，密钥管理和安全协议的正确实施也是确保安全性的重要因素。</p>
<h2 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4.遇到的问题"></a>4.遇到的问题</h2><p>解决方法:</p>
<ul>
<li>Change the algorithm class. Replace the class to one. RijndaelManagedAESManaged</li>
<li>Do not explicit set the of algorithm class, left them default.<br>(This is the very important step. I think there is a bug in KeySize property.)KeySize<img alt="系统安全理论上机报告-trouble1.png" src="ga-hexo\source\_drafts\systemSafeTheory\assets\系统安全理论上机报告-trouble1.png">
端口号占用的问题</li>
<li>netstat -aon|findstr “1234”</li>
<li>tasklist|findstr “1234”</li>
</ul>
<h2 id="5-心得体会"><a href="#5-心得体会" class="headerlink" title="5.心得体会"></a>5.心得体会</h2><p>当学习CBC（Cipher Block Chaining）在TCP中的传输时，我获得了以下心得体会：</p>
<p>首先，CBC模式是一种常用的块密码模式，通过使用前一个密文块作为当前明文块的输入，实现了消息的链接和依赖性。这种链接性使得CBC在TCP传输中能够提供一定的保密性和完整性。</p>
<p>其次，CBC模式的关键在于初始向量（IV）的选择和使用。IV是用于引入随机性和唯一性的重要参数，它在每个数据块的加密过程中都是不同的。因此，在TCP传输中，需要确保IV的安全性和唯一性，以防止攻击者利用重放攻击等方式来破解加密。</p>
<p>另外，填充（Padding）的处理也是CBC模式中需要注意的一点。填充是为了确保明文块的长度满足加密算法的要求，通常使用标准的填充方案（如PKCS7）。在TCP传输中，我们需要确保填充的正确性和完整性，以防止填充攻击等安全漏洞的出现。</p>
<p>在实际应用中，我意识到CBC模式在TCP传输中还需要考虑性能和安全性之间的权衡。加密和解密过程会增加数据传输的延迟，特别是对于大数据流的传输，可能会对性能产生一定的影响。因此，我们需要根据实际需求和场景来评估和权衡安全性和性能之间的取舍。</p>
<p>在学习CBC模式的过程中，我还深刻认识到数据完整性和可靠性的重要性。CBC模式能够提供一定程度的数据完整性保护，但仍然需要结合消息认证码（MAC）等机制来确保数据的完整性和身份验证。</p>
<p>总而言之，学习CBC在TCP传输中的应用是一项挑战和有趣的任务。通过理解CBC模式的原理和特点，结合实际应用中的安全需求和性能考虑，我们可以更好地应用CBC模式来实现安全的数据传输，并在保护数据的同时提供高效可靠的通信。</p>
]]></content>
  </entry>
  <entry>
    <title>hot30</title>
    <url>/2024/04/19/hot30/</url>
    <content><![CDATA[<h1 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a>前k个高频元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (a,b) -&gt; (a.getValue() - b.getValue())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; num : map.entrySet())&#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">if</span>(minHeap.size() &gt; k)&#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            ans[i] = minHeap.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前k个高频单词"><a href="#前k个高频单词" class="headerlink" title="前k个高频单词"></a>前k个高频单词</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用最小堆,复杂度O(n):Nlogk*/</span></span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            (a,b) -&gt;(a.getValue() - b.getValue())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            minHeap.offer(entry);</span><br><span class="line">            <span class="keyword">if</span>(minHeap.size() &gt; k)&#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            ans[i] = minHeap.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">快速选择*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 使用HashMap统计元素出现的频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将频率映射到一个数组</span></span><br><span class="line">        <span class="type">int</span>[] frequencies = <span class="keyword">new</span> <span class="title class_">int</span>[map.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> frequency : map.values()) &#123;</span><br><span class="line">            frequencies[index++] = frequency;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用快速选择找到第k个最大的频率</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">kthLargestFrequency</span> <span class="operator">=</span> quickSelect(frequencies, <span class="number">0</span>, frequencies.length - <span class="number">1</span>, frequencies.length - k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造结果数组</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() &gt;= kthLargestFrequency) &#123;</span><br><span class="line">                ans[index++] = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速选择算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果数组中只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选择一个基准元素并获取其索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> randomPartition(nums, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果基准元素正好是第k个最大的元素</span></span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k) &#123;</span><br><span class="line">            <span class="comment">// 在右侧继续查找</span></span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在左侧继续查找</span></span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机选择基准元素进行分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 随机选择一个索引作为基准元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将基准元素移动到数组的最右端</span></span><br><span class="line">        swap(nums, pivotIndex, right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将小于或等于基准元素的元素移到左侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将基准元素放回其正确的位置</span></span><br><span class="line">        swap(nums, i, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="按字典序排在最后的字串"><a href="#按字典序排在最后的字串" class="headerlink" title="按字典序排在最后的字串"></a>按字典序排在最后的字串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lastSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用TreeSet来存储所有的子串并自动按字典序排序</span></span><br><span class="line">        TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 遍历字符串s的所有可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                set.add(s.substring(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回TreeSet中的最后一个元素，即按字典序排序后的最后一个子串</span></span><br><span class="line">        <span class="keyword">return</span> set.last();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="comment">//链表的值的改变一定是想要改的一方被赋值</span></span><br><span class="line"><span class="comment">//pre想要去cur的位置</span></span><br><span class="line"><span class="comment">//pre = cur</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">urr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="comment">//nk-1 -&gt; nk -&gt; nk+1</span></span><br><span class="line"><span class="comment">//我们希望nk+1指向nk</span></span><br><span class="line"><span class="comment">//nk.next.next = nk</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DlinkedList</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        DlinkedList next;</span><br><span class="line">        DlinkedList pre;</span><br><span class="line"></span><br><span class="line">        DlinkedList() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DlinkedList(<span class="type">int</span> val, <span class="type">int</span> key) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, DlinkedList&gt; cache;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    DlinkedList head;</span><br><span class="line">    DlinkedList tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DlinkedList</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DlinkedList</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DlinkedList</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DlinkedList</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">DlinkedList</span>(value, key);</span><br><span class="line">                addToHead(node);</span><br><span class="line">                cache.put(key, node);</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeTail();</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">DlinkedList</span>(value, key);</span><br><span class="line">                addToHead(node);</span><br><span class="line">                cache.put(key, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DlinkedList node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DlinkedList</span> <span class="variable">tailNode</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        removeNode(tailNode);</span><br><span class="line">        cache.remove(tailNode.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DlinkedList node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DlinkedList node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum==<span class="number">0</span>) &#123;</span><br><span class="line">                        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ca = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            ca[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : ca)&#123;</span><br><span class="line">            count += num % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//abbba</span></span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span> ? s.length() : s.length() - count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归的查看当前子树的节点中是否包含p和q节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode res=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        traver(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">traver</span><span class="params">(TreeNode root,TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a=traver(root.left,p,q);</span><br><span class="line">        <span class="type">int</span> b=traver(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=a+b;</span><br><span class="line">        <span class="keyword">if</span>(root.val==p.val||root.val== q.val) sum+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res==<span class="literal">null</span>&amp;&amp;sum==<span class="number">2</span>)  res=root;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="comment">//dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=len1; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=len2; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">            dummy = merge(dummy,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode heada,ListNode headb)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> heada;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headb;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(a!= <span class="literal">null</span> &amp;&amp; b!= <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.val &lt;= b.val)&#123;</span><br><span class="line">                pre.next = a;</span><br><span class="line">                a = a.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.val &gt; b.val)&#123;</span><br><span class="line">                pre.next = b;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = (a == <span class="literal">null</span>) ? b : a;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(; right &lt; nums.length; right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line">                min = Math.min(min,right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> list1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> list2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                pre.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l1.val &gt;= l2.val)&#123;</span><br><span class="line">                pre.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = (l1 == <span class="literal">null</span>) ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        String[] res1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] res2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;res1.length || i &lt; res2.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; res1.length)&#123;</span><br><span class="line">                x = Integer.parseInt(res1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; res2.length)&#123;</span><br><span class="line">                y = Integer.parseInt(res2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; y)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; y)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//有两个区间范围</span></span><br><span class="line">    <span class="comment">//从0到len-1</span></span><br><span class="line">    <span class="comment">//从1到len </span></span><br><span class="line">    <span class="comment">//其中x,y,z 表示前两个房间的的金额和.当前要偷的房间的金额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxPrice(nums,<span class="number">0</span>,len - <span class="number">1</span>),maxPrice(nums,<span class="number">1</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPrice</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i&lt;end; i++)&#123;</span><br><span class="line">            y = z;</span><br><span class="line">            z = Math.max(y, x + nums[i]);</span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                temp = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">                profit += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一共假设有三段路,第一段从出发点到入口: a 从入口到相遇点: b, 从相遇点到入口: c</span></span><br><span class="line"><span class="comment">     * 其中b+c = L</span></span><br><span class="line"><span class="comment">     * 另外可以知道a的距离 a+b</span></span><br><span class="line"><span class="comment">     * 那么b的距离 2*(a+b)</span></span><br><span class="line"><span class="comment">     * 可以得到2*(a+b) = a + n * (b + c) + b</span></span><br><span class="line"><span class="comment">     * a = (n - 1)* b + n * c = (n - 1) * L + c</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到快慢指针相遇的点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到循环的起始点</span></span><br><span class="line">        fast = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt;= end &amp;&amp; !Character.isLetterOrDigit(s.charAt(end)))&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt;= end &amp;&amp; !Character.isLetterOrDigit(s.charAt(start)))&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="移掉k位数字"><a href="#移掉k位数字" class="headerlink" title="移掉k位数字"></a>移掉k位数字</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; k&gt;<span class="number">0</span> &amp;&amp; stack.peekLast() &gt; digit)&#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.offerLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            stack.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isZero</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> stack.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(isZero &amp;&amp; digit == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isZero = <span class="literal">false</span>;</span><br><span class="line">            sb.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两两交换链表中的结点"><a href="#两两交换链表中的结点" class="headerlink" title="两两交换链表中的结点"></a>两两交换链表中的结点</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> node1.next;</span><br><span class="line"></span><br><span class="line">            pre.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line"></span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优势洗牌"><a href="#优势洗牌" class="headerlink" title="优势洗牌"></a>优势洗牌</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] advantageCount(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//核心在于进行匹配num1中的元素进行放置</span></span><br><span class="line">        Integer[] idx1 = <span class="keyword">new</span> <span class="title class_">Integer</span>[nums1.length];</span><br><span class="line">        Integer[] idx2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[nums2.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            idx1[i] = i;</span><br><span class="line">            idx2[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(idx1, (i, j) -&gt; nums1[i] - nums1[j]);</span><br><span class="line">        Arrays.sort(idx2, (i, j) -&gt; nums2[i] - nums2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums1.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[idx1[i]] &gt; nums2[idx2[left]])&#123;</span><br><span class="line">                ans[idx2[left]] = nums1[idx1[i]];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 ans[idx2[right]] = nums1[idx1[i]];</span><br><span class="line">                 right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traverse(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        traverse(root.left,ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        traverse(root.right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时弹出的是一个null</span></span><br><span class="line">            root = stack.pop();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            max = Math.max(max,sum);</span><br><span class="line">            sum = Math.max(sum,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="k个逆序对数组"><a href="#k个逆序对数组" class="headerlink" title="k个逆序对数组"></a>k个逆序对数组</h1><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">below</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= below) &#123;</span><br><span class="line">            <span class="comment">// Traverse top row</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                ans.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse right column</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= below; i++) &#123;</span><br><span class="line">                ans.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse bottom row</span></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= below) &#123; <span class="comment">// Check if top and below pointers are still valid</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) &#123;</span><br><span class="line">                    ans.add(matrix[below][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                below--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse left column</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123; <span class="comment">// Check if left and right pointers are still valid</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> below; i &gt;= top; i--) &#123;</span><br><span class="line">                    ans.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] ca = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">27</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ca[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;len; i++)&#123;</span><br><span class="line">            idx = Math.max(idx,ca[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(idx == i)&#123;</span><br><span class="line">                ans.add(i - last);</span><br><span class="line">                last = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move fast pointer n steps ahead</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// List length is less than n</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move both pointers until fast reaches the end</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove the nth node from the end</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="多个数组求交集"><a href="#多个数组求交集" class="headerlink" title="多个数组求交集"></a>多个数组求交集</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>[][] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : arr)&#123;</span><br><span class="line">                cnt[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">1001</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == len)&#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> * val = x;</span></span><br><span class="line"><span class="comment"> * next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums, i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">plen</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= slen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= plen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (matches(s, p, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matches(s, p, i, j)) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String s, String p, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a>全排列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>internship</title>
    <url>/2024/05/29/internship/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">公司名</th>
<th align="center">投递岗位</th>
<th align="center">投递时间</th>
<th align="center">测评</th>
<th align="center">笔试</th>
<th align="center">一面</th>
<th align="center">二面</th>
<th align="center">情况</th>
<th align="center">状态</th>
<th align="center">Base</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><del>快手</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;27</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">4&#x2F;8(√)</td>
<td align="center">4&#x2F;10(×)</td>
<td align="center">后端挂</td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">百度</td>
<td align="center">后端</td>
<td align="center">3&#x2F;27</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">简历挂</td>
<td align="center">泡池子</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">58同城</td>
<td align="center">后端</td>
<td align="center">3&#x2F;28</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">泡池子</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>阿里淘天</del></td>
<td align="center">后端(测开)</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">后端挂 测开挂</td>
<td align="center">已结束</td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center"><del>美团</del></td>
<td align="center">后端(测开)</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">4&#x2F;11(√) 5&#x2F;07(×)</td>
<td align="center">4&#x2F;12(×)</td>
<td align="center">后端挂 测开挂 复活挂</td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>腾讯</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">4&#x2F;23(×)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center"><del>携程</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">笔试挂</td>
<td align="center">进池子</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">字节</td>
<td align="center">后端(测开)</td>
<td align="center">3&#x2F;31</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">泡池子</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>北森</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">×</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">测评未做</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">京东</td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">泡池子</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>华为</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">西安</td>
</tr>
<tr>
<td align="center"><del>饿了么</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">小红书</td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">泡池子</td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center"><del>钉钉</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">菜鸟</td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">泡池子</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>拼多多</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">笔试挂</td>
<td align="center">已结束</td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center"><del>oppo</del></td>
<td align="center">后端</td>
<td align="center">3&#x2F;31</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">百度(电商)</td>
<td align="center">后端</td>
<td align="center">4&#x2F;1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>小米</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">简历挂</td>
<td align="center">泡池子</td>
<td align="center">西安</td>
</tr>
<tr>
<td align="center">阅文集团</td>
<td align="center">后端</td>
<td align="center">4&#x2F;2</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center"><del>搜狐</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">Amazon</td>
<td align="center">后端</td>
<td align="center">4&#x2F;3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">泡池子</td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center"><del>shopee</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;3</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>贝壳</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>安克创新</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;3</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">无HC</td>
<td align="center">已结束</td>
<td align="center">长沙</td>
</tr>
<tr>
<td align="center"><del>众安保险</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;6</td>
<td align="center"></td>
<td align="center">×</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">联想</td>
<td align="center">后端</td>
<td align="center">4&#x2F;6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">腾讯音乐</td>
<td align="center">后端</td>
<td align="center">4&#x2F;10</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center"><del>bilibili</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;11</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">笔试挂</td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">滴滴</td>
<td align="center">后端</td>
<td align="center">4&#x2F;11</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">网易</td>
<td align="center">后端</td>
<td align="center">4&#x2F;11</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">高德地图</td>
<td align="center">后端</td>
<td align="center">4&#x2F;12</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>SHEIN</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;12</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">南京</td>
</tr>
<tr>
<td align="center">哈啰</td>
<td align="center">后端</td>
<td align="center">4&#x2F;12</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">知乎</td>
<td align="center">后端</td>
<td align="center">4&#x2F;12</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">南京</td>
</tr>
<tr>
<td align="center">欢聚</td>
<td align="center">后端</td>
<td align="center">4&#x2F;14</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">广州</td>
</tr>
<tr>
<td align="center">阿里巴巴</td>
<td align="center">后端</td>
<td align="center">4&#x2F;14</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center"><del>蔚来</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;14</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">日常实习</td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">TP-Link</td>
<td align="center">后端</td>
<td align="center">4&#x2F;16</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center">零跑汽车</td>
<td align="center">后端</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">大疆</td>
<td align="center">后端</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center">灵犀互娱</td>
<td align="center">后端</td>
<td align="center">4&#x2F;17</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">广州</td>
</tr>
<tr>
<td align="center">HelloTalk</td>
<td align="center">测开</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center">Wind</td>
<td align="center">后端</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">南京</td>
</tr>
<tr>
<td align="center"><del>禾赛科技</del></td>
<td align="center">测开</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">不符合</td>
<td align="center">已结束</td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">SAP</td>
<td align="center">后端</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">广州</td>
</tr>
<tr>
<td align="center">帆软</td>
<td align="center">后端</td>
<td align="center">4&#x2F;17</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">成都&#x2F;南京</td>
</tr>
<tr>
<td align="center">荣耀</td>
<td align="center">后端</td>
<td align="center">4&#x2F;18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">西安</td>
</tr>
<tr>
<td align="center">TSMC</td>
<td align="center">后端</td>
<td align="center">4&#x2F;18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海&#x2F;南京</td>
</tr>
<tr>
<td align="center">特斯拉</td>
<td align="center">测开</td>
<td align="center">4&#x2F;18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center"><del>文远知行</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;18</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">已结束</td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">慧策</td>
<td align="center">后端</td>
<td align="center">4&#x2F;18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">美团</td>
<td align="center">后端</td>
<td align="center">4&#x2F;20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">日常实习×8</td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">快手</td>
<td align="center">后端</td>
<td align="center">4&#x2F;20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">日常实习×8</td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">网易</td>
<td align="center">后端</td>
<td align="center">4&#x2F;20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">日常实习</td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">字节</td>
<td align="center">后端</td>
<td align="center">4&#x2F;20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">日常实习×8</td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">Apple</td>
<td align="center">后端</td>
<td align="center">4&#x2F;20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">日常实习</td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center"><del>宁德时代</del></td>
<td align="center">后端</td>
<td align="center">4&#x2F;21</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">宁德</td>
</tr>
<tr>
<td align="center">CARIAD</td>
<td align="center">后端</td>
<td align="center">4&#x2F;21</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">安恒</td>
<td align="center">后端</td>
<td align="center">4&#x2F;21</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">招联</td>
<td align="center">后端</td>
<td align="center">4&#x2F;21</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">广州</td>
</tr>
<tr>
<td align="center">太极计算</td>
<td align="center">后端</td>
<td align="center">4&#x2F;21</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">西安</td>
</tr>
<tr>
<td align="center">阿里妈妈</td>
<td align="center">后端</td>
<td align="center">4&#x2F;21</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">比亚迪</td>
<td align="center">后端</td>
<td align="center">4&#x2F;22</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">成都&#x2F;北京</td>
</tr>
<tr>
<td align="center">奇安信</td>
<td align="center">后端</td>
<td align="center">4&#x2F;23</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">武汉</td>
</tr>
<tr>
<td align="center">阿里大文娱</td>
<td align="center">后端</td>
<td align="center">4&#x2F;23</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">明源云</td>
<td align="center">后端</td>
<td align="center">4&#x2F;24</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">中兴</td>
<td align="center">后端</td>
<td align="center">4&#x2F;26</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">成都</td>
</tr>
<tr>
<td align="center">凯捷咨询</td>
<td align="center">后端</td>
<td align="center">4&#x2F;26</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">海康威视</td>
<td align="center">后端</td>
<td align="center">4&#x2F;29</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">卡夫亨氏</td>
<td align="center">后端</td>
<td align="center">4&#x2F;30</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">网易游戏</td>
<td align="center">后端&#x2F;测开</td>
<td align="center">4&#x2F;30</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">广州</td>
</tr>
<tr>
<td align="center">盒马</td>
<td align="center">测开</td>
<td align="center">5&#x2F;3</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">滴滴</td>
<td align="center">后端</td>
<td align="center">5&#x2F;3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">恒生电子</td>
<td align="center">后端</td>
<td align="center">5&#x2F;3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">腾讯云智</td>
<td align="center">后端&#x2F;测开</td>
<td align="center">5&#x2F;3</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">5&#x2F;16(?)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">武汉&#x2F;西安</td>
</tr>
<tr>
<td align="center">传音</td>
<td align="center">后端</td>
<td align="center">5&#x2F;3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">重庆</td>
</tr>
<tr>
<td align="center">神州信息</td>
<td align="center">后端</td>
<td align="center">5&#x2F;5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">腾娱互动</td>
<td align="center">后端</td>
<td align="center">5&#x2F;5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">成都</td>
</tr>
<tr>
<td align="center">东方财富</td>
<td align="center">后端</td>
<td align="center">5&#x2F;6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">顺丰</td>
<td align="center">后端</td>
<td align="center">5&#x2F;8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">武汉</td>
</tr>
<tr>
<td align="center">云鲸智能</td>
<td align="center">后端</td>
<td align="center">5&#x2F;8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">星展银行</td>
<td align="center">后端</td>
<td align="center">5&#x2F;8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">博世</td>
<td align="center">后端</td>
<td align="center">5&#x2F;8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">曼伦</td>
<td align="center">后端</td>
<td align="center">5&#x2F;8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">思特奇</td>
<td align="center">后端</td>
<td align="center">5&#x2F;9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">合肥&#x2F;济南</td>
</tr>
<tr>
<td align="center">长亭科技</td>
<td align="center">后端</td>
<td align="center">5&#x2F;9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">北京</td>
</tr>
<tr>
<td align="center">蚂蚁</td>
<td align="center">后端</td>
<td align="center">5&#x2F;9</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">成都</td>
</tr>
<tr>
<td align="center">阿里国际</td>
<td align="center">测开&#x2F;后端</td>
<td align="center">5&#x2F;9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">杭州</td>
</tr>
<tr>
<td align="center">微众银行</td>
<td align="center">测开&#x2F;后端</td>
<td align="center">5&#x2F;10</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">武汉</td>
</tr>
<tr>
<td align="center">MoonBit</td>
<td align="center">后端&#x2F;测开</td>
<td align="center">5&#x2F;10</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center">TapTap</td>
<td align="center">测开</td>
<td align="center">5&#x2F;15</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">5&#x2F;16(?)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>review</category>
      </categories>
      <tags>
        <tag>internship</tag>
      </tags>
  </entry>
  <entry>
    <title>internshipReview</title>
    <url>/2024/05/29/internshipReview/</url>
    <content><![CDATA[<h1 id="快手-海外电商"><a href="#快手-海外电商" class="headerlink" title="快手(海外电商)"></a>快手(海外电商)</h1><h2 id="快手一面-4-8"><a href="#快手一面-4-8" class="headerlink" title="快手一面(4.8)"></a>快手一面(4.8)</h2><ol>
<li><p>你是如何进行考虑你的项目的?你为什么要想着写这样的两个项目,你学校学过java吗,如何进行学习的</p>
<p>阿巴阿巴……</p>
</li>
<li><p>来考察一下你的java的基础知识吧,如果我们对于一个Map的结构进行插入会发现十分的慢?这是为什么?</p>
<p>map的实现是由数组＋链表完成,因此会进行O(n)的插入操作,分开将jdk1.8之前和之后 </p>
</li>
<li><p>如果你进行优化你会如何进行优化</p>
<p>开始头脑风暴…..首先我想的是将传统的拉链法进行优化,我们可以优化成地址探测法加拉链法……(看得出不太满意,现在复盘发现有点离谱)</p>
</li>
<li><p>这样会导致什么问题?</p>
<p>如果我们进行插入的时候我们会发现要不断的进行数组的扩容</p>
</li>
<li><p>除了对于数组进行操作,我们还可以进行什么操作(面试官tip: 从链表的结构,我们不用转化成红黑树)</p>
<p>继续头脑风暴…..用redis中的跳表,给索引构建索引</p>
</li>
<li><p>还行,你讲一下跳表和红黑树,为什么redis要使用跳表而不使用红黑树,红黑树的开销问题</p>
<p>吟唱失败,(从redis的使用场景进行考虑),redis主要是用作内存,因此从插入的角度来进行考虑,如果使用插入的范围比较范围比较小的话我觉得跳表的开销可能小于红黑树(又开始问如何进行算开销),红黑树学的依托答辩,现场吟唱失败直接说忘了,最后提示到如何进行调整</p>
</li>
<li><p>开始提问Spring,列举一下Spring你是如何进行理解的</p>
<p>又开始胡说(框架是基本上一点没学),阿巴阿巴</p>
</li>
<li><p>那你说一下你是如何进行理解SpringBoot和Spring的吧</p>
<p>Spring Boot是Spring的升级版…….(被及时更正了),(如何进行理解boot),巴拉巴拉,我觉得boot是启动得意思,算了好好看.</p>
</li>
<li><p>如何理解Spring MVC的</p>
<p>把三个层讲了一下,随便吟唱了一下dispatcher的分发过程(又打断)如果没有dispatcher怎么办,我觉得还是不知道(奶龙抬头,骄傲)(又给小建议,下去看一下旧技术)(突然想起旧的技术不是RESTFUL吗…….统一响应,我真服了)</p>
</li>
<li><p>(噩梦时刻) 我看你写了你熟悉读写分离,那你来讲一下吧</p>
<p>(心想),真服了……数据库是啥,不熟……胡说到了冷热分离,我真服了,接着又开始提示使用主从结构,瞬间联想到了binlog,然后开始吟唱项目二的binlog实现(接着问,你是要自己实现吗)答曰是的</p>
</li>
<li><p>面试官人帅心善,说下去再看一下,binlog数据库本身可以实现</p>
</li>
<li><p>下来问了一下如何判断表的索引性能</p>
<p>支支吾吾了半天,想出了个explain…..</p>
</li>
<li><p>给了一下语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">idx(id,name,sex)</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line"><span class="comment">--能执行到吗</span></span><br><span class="line"><span class="comment">--想了半天,哼哼了个最左匹配,但是不会</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下去好好看看sql高性能优化(好的,疯狂感谢)</p>
</li>
<li><p>来做道题吧……..算了,今天到此结束(<strong>最早什么时候能来</strong>,六月多,<strong>实习多久</strong>:三个月以上)</p>
</li>
<li><p>反问,您好,您现在的方向是什么,<strong>快手海外电商</strong></p>
</li>
<li><p>那快手加班强度怎么样,<strong>不大,没有大小周</strong></p>
</li>
</ol>
<blockquote>
<p>总结: 数据库太差,框架只能说个大概,面试心态比想象中的略好一点,面试官人很好,很会循序渐进,中间打断面试官吟唱太多,下次改进.整体面试不到半个小时,人麻了,以为完了,结果十分钟二面的通知就来了……</p>
</blockquote>
<h2 id="快手二面-4-10"><a href="#快手二面-4-10" class="headerlink" title="快手二面(4.10)"></a>快手二面(4.10)</h2><ol>
<li><p>(来自TeamLeader的压迫,压力拉满了,凉经)自我介绍,介绍一下项目</p>
<p>阿巴阿巴……..</p>
</li>
<li><p>介绍一下项目难点</p>
<p>(有一说一,一定要项目在底下的时候就复盘好&#x2F;讲好项目难点,本来想的好好的介绍技术选型问题,结果一张嘴就直接开始胡说)再熬两天迟早得死在这里,今天状态奇差</p>
</li>
<li><p>优惠券数据超发的问题</p>
<p>张嘴就死,md…….直接把异步线程池都整上了(<del>好像也没问题</del>,出大问题了)</p>
</li>
<li><p>还有一个如何进行确定是不是有人重复领取了</p>
<p>答曰:<del>实现规则类</del>,MQ重复消费,全局唯一id</p>
</li>
<li><p>如何保持数据的一致性</p>
<p>直接吟唱redis和数据库的一致性</p>
</li>
<li><p>如何保持数据库的准确性</p>
<p>直接开始吟唱kafka……..(能看得出面试官大为震惊…….”你kafka咋保证数据的准确性的?”),继续绕,我觉得使用kafka保持它的顺序……..md羞耻死了,然后往深里面讲了一下….</p>
<p>(4&#x2F;13刚看到分布式id……本来异步进行生成优惠券码就是保证了准确性)</p>
</li>
<li><p>线程池的相关概念</p>
<p>八股盛宴,初始化线程池的过程</p>
</li>
<li><p>行, 再问一下Java,(又是HashMap),我真是服了HashMap的扩容咋阔我都给忘了…..qwq</p>
</li>
<li><p>再问一下SpringBoot的自动装配,三个注解也忘光了,就说上了个autoconfiguraion也栓q</p>
</li>
<li><p>再问一下你知道的哪些锁,终于爽了一会,搬回一局</p>
<p>基于AQS的Schronoized,ReentrantLock,StampLock,Semaphore一起拉出来狠狠的进行装了一番</p>
</li>
<li><p>锁的升级过程</p>
<p>更爽了….再次吟唱</p>
</li>
<li><p>来了一道反转链表…..结果有的b就只能写出非递归……..想来两锤</p>
</li>
<li><p>万一过了,什么时候能来…</p>
<p>继续六月底…….</p>
</li>
<li><p>反问: 哪个部门?(海外电商)对于实习生的培养(好),好!</p>
</li>
</ol>
<blockquote>
<p>果然二面是名不虚传的压力面,给的强度上满了,一面有互动,二面只有嗯,行,好,我知道了…….继续38分钟解决战斗,太亏贼了……行吧,快手再见……</p>
</blockquote>
<h1 id="快手-质量效能组"><a href="#快手-质量效能组" class="headerlink" title="快手(质量效能组)"></a>快手(质量效能组)</h1><h2 id="快手一面-5-27"><a href="#快手一面-5-27" class="headerlink" title="快手一面(5.27)"></a>快手一面(5.27)</h2><ol>
<li><p>讲一下两个项目</p>
<p>阿巴阿巴……</p>
</li>
<li><p>讲一下你理解的redis和mysql</p>
</li>
<li><p>为什么redis可以基于内存,如何保证数据不丢失?</p>
<p>rdb或AOF?</p>
</li>
<li><p>Tcp和udp的区别是什么</p>
</li>
<li><p>负载均衡原理</p>
<p>想不起来,没好意思说,就提了几下负载均衡的算法</p>
</li>
<li><p>java中避免死锁的方法</p>
<p>就说上来了个锁在Java中避免死锁是一个重要的编程任务，特别是在多线程编程中。以下是一些常用的方法来避免死锁：</p>
<ol>
<li><p><strong>避免嵌套锁</strong>：<br>尽量减少一个线程持有多个锁的情况。这样可以降低发生死锁的风险。</p>
</li>
<li><p><strong>锁的顺序</strong>：<br>确保所有线程以相同的顺序获得锁。例如，如果线程A和线程B都需要锁L1和锁L2，那么确保它们总是先获取锁L1，再获取锁L2。这可以通过定义全局锁顺序来实现。</p>
</li>
<li><p><strong>使用超时尝试获取锁</strong>：<br>使用<code>tryLock</code>方法代替<code>lock</code>方法，这样可以设定一个超时时间。如果无法在超时时间内获取锁，线程可以放弃获取锁，从而避免死锁。示例如下：</p>
</li>
<li><p><strong>避免长时间持有锁</strong>：<br>锁的持有时间越长，发生死锁的可能性越大。因此，应尽量减少锁持有的时间，仅在需要的时候持有锁，并在完成后立即释放。</p>
</li>
<li><p><strong>使用更高层次的锁管理机制</strong>：<br>使用Java并发包中的高级并发工具，例如<code>java.util.concurrent</code>包中的<code>Lock</code>, <code>ReentrantLock</code>, <code>ReadWriteLock</code>等，它们提供了更灵活的锁管理机制。</p>
</li>
<li><p><strong>检测和预防死锁</strong>：<br>实现死锁检测机制，监视线程获取锁的状态，如果检测到死锁，采取适当的措施（例如中断相关线程）。一些工具和库可以帮助检测死锁，例如JConsole和VisualVM。</p>
</li>
</ol>
</li>
<li><pre><code class="java">//括号匹配
//大喊我是傻逼
import java.util.*;
public class Main &#123;
    public static void main(String[] args) &#123;
        //String str = &quot;niin&quot;; // 不是真有傻逼这样写
        String str = &quot;((())))&quot;;
        Deque&lt;Character&gt; stk = new LinkedList&lt;&gt;();
        for(char c : str.toCharArray())&#123;
            if(c == &#39;(&#39;)&#123;
                stk.push(&#39;)&#39;);
            &#125;else if(c == &#39;&#123;&#39;)&#123;
                stk.push(&#39;&#125;&#39;);
            &#125;else if(c == &#39;[&#39;)&#123;
                stk.push(&#39;]&#39;);
            &#125;else if(stk.isEmpty() || stk.peek() != c)&#123;
                break;
            &#125;else&#123;
                stk.pop();
            &#125;
        &#125;
        boolean flag = stk.isEmpty();
        System.out.println(flag);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. 大文件传输用udp还是tcp</span><br><span class="line"></span><br><span class="line">9. ```sql</span><br><span class="line">   --A一个表name,id,socre</span><br><span class="line">   --B一个表id,major</span><br><span class="line">   select A.name,B.major</span><br><span class="line">   from A</span><br><span class="line">   join B on A.id = B.id</span><br><span class="line">   where A.score &gt; 60</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>反问: 部门,效能开发,偏向于开发是吧</p>
</li>
</ol>
<blockquote>
<p>快手的一面果然还是一如既往的高效且温柔,速度极快,就是我的水平太差了,但是!,她以为我是研究生,最后还挺不好意思的,最后没问什么就直接给我过了(38min)</p>
</blockquote>
<h2 id="快手二面-5-28"><a href="#快手二面-5-28" class="headerlink" title="快手二面(5.28)"></a>快手二面(5.28)</h2><ol>
<li><p>老生常谈,项目哪里来的</p>
</li>
<li><p>介绍一下项目,什么是构建索引,啥都不懂,我真的服了</p>
</li>
<li><p>优惠券项目的流程</p>
</li>
<li><p>平时都会什么,java,sql,linux,中间件</p>
</li>
<li><p>来道题,判断ip是否有效(题写的依托狗屎)</p>
</li>
<li><p>反问: 是否偏开发</p>
<blockquote>
<p>没意思,感觉不会中间件,问的东西都很无聊,面了五分钟我就想放弃了,最后强撑着面完了,讨厌女面试官(44min)</p>
</blockquote>
</li>
</ol>
<h1 id="美团-到家"><a href="#美团-到家" class="headerlink" title="美团(到家)"></a>美团(到家)</h1><h2 id="美团一面-4-11"><a href="#美团一面-4-11" class="headerlink" title="美团一面(4.11)"></a>美团一面(4.11)</h2><ol>
<li><p>讲一下项目,项目中的难点</p>
<p>阿巴阿巴…….</p>
</li>
<li><p>(开始八股),了解java知识,讲一下ArrayList和LinkedList的区别</p>
<p>底层区别,实现的接口,插入复杂度讲了一大堆</p>
</li>
<li><p>解决hash冲突的方法</p>
<p>hashmap中使用的拉链法,还有地址探测法</p>
</li>
<li><p>讲一下拆包和装包</p>
<p>八股盛宴,讲了下</p>
</li>
<li><p>知道optional吗,</p>
<p><del>讲了几句class类中的泛型好像见过,</del>不知道……(接着普及了一下,空指针处理的)</p>
</li>
<li><p>讲一下Spring中的常见的部件(还是包装什么的,忘了)</p>
<p>讲了一下有什么@component@data@controller,可以进行从上往下进行注入</p>
</li>
<li><p>知道jvm么,讲一下jvm中常见的参数</p>
<p>(神参数,一丁点也想不起来),就说了一下线程的状态转化(md,真离谱,想到了-xms-xmx了,不敢说)</p>
</li>
<li><p>讲一下线程池,线程池的初始化</p>
<p>core,queue,max,进行注入的过程,还有keepAlive之类的巴拉了一会儿</p>
</li>
<li><p>讲一下线程池的调优</p>
<p>这问法有点迷惑,(讲了一下发现就是如何进行初始化线程池的数量)cpuN+1,io2*N(结果他还讲反了,现场想纠正,一想算了)</p>
</li>
<li><p>讲一下mybatis中的横杠和井号啥的区别(应该是这个问题)</p>
<p>直接就说没学过</p>
</li>
<li><p>来问个mysql的知识吧,什么是sql注入</p>
<p>开始瞎说(听不下去了打断施法),最后提起hacker的做法,瞬间想到峰神讲的黑科技,过去的跳过密码的做法,然后就插入了几句()</p>
</li>
<li><p>讲一下redis</p>
<p>计算机中的cache,实现数据处理速度不一致的问题</p>
</li>
<li><p>再讲一下kafka</p>
<p>处理redis和mysql不一致的问题</p>
</li>
<li><p>做题,一道链表交叉插入的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">有链表l1-&gt;l2-&gt;l3-&gt;l4.....-&gt;ln-1-&gt;ln</span></span><br><span class="line"><span class="comment">进行改变链表的结构</span></span><br><span class="line"><span class="comment">l1-&gt;ln-&gt;l2-&gt;ln-1-&gt;l3-&gt;ln-3.......</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">我的做法全局翻转直接翻转再插入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">面试官改进了一下,找到中间节点再进行插入,我的做法会改变链表的结构</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最近看什么书,(直接信息论+马尔科夫链开始吹牛逼)(感谢Garfield)</p>
</li>
<li><p>讲一下了解到的大模型</p>
<p>chatgpt,sora1,sora2,vercel之类的</p>
</li>
<li><p>反问:进去公司对于实习生的要求(导师一对一,会干活),另外给我讲了一下部门的情况,偏向开发的测试,而不是单纯的点点点</p>
</li>
</ol>
<blockquote>
<p>总结,jvm比预想中的差一些,有些细节抓的还是不够,面试官反馈挺好,美团果然面试舒服,三十八分钟</p>
</blockquote>
<h2 id="美团二面-4-12"><a href="#美团二面-4-12" class="headerlink" title="美团二面(4.12)"></a>美团二面(4.12)</h2><ol>
<li><p>自我介绍….</p>
<p>介绍了一会儿,稍微聊了一会儿(感觉面试官真的很温柔)</p>
</li>
<li><p>直接从java开始入手,项目中用到了哪些集合的框架,简单的介绍一下</p>
<p>使用了HashMap进行对于优惠券的增删改查,其次使用到了List进行对于优惠券的redis和数据库的添加</p>
</li>
<li><p>提到了List,简单的介绍一下你所知道的List</p>
<p>反复的八股吟唱,ArrayList,LinkedList,继续底层,插入实现(还问了一下使用的场景),再次进行了吟唱还提说到了线程不安全,(线程安全的你知道哪些)copyonwriteArrayList,顺便讲了一下原理,(为什么不使用),我觉得可以从上层进行避免,开销大</p>
</li>
<li><p>讲一下java中的error和execption</p>
<p>爽文,夸夸输出(还有一道场景题,有点忘了)</p>
</li>
<li><p>讲一下java中的io,你有没有用到</p>
<p>项目中进行dump文件,字符流字节流都讲了一下</p>
</li>
<li><p>讲一下HashMap</p>
<p>继续从底层开始讲起,什么扩容啊之类的都一起讲了,(再继续深挖了一下)讲到了什么loadindex</p>
</li>
<li><p>聊到了线程,线程池的核心参数</p>
<p>爽文,再次进行吟唱,加入线程池的过程</p>
</li>
<li><p>顺便问了一下,如果线程池饱和了应该怎么办,</p>
<p>进行abortpolicy,还有进行callable自我进行调用,(其实是callerrunspolicy)(还有哪些)想不到了</p>
</li>
<li><p>进行拷打mysql,看你写了mysql的调优,来讲一下吧</p>
<p>首先进行查看log文件,我们可以知道问题出在了哪里,其次我们可以使用explain语句进行查看是否走了索引,核心点在于是否走了索引</p>
</li>
<li><p>如果我们发现了所有的检索我们都走了索引但是查询还是很慢应该怎么办</p>
<p>我觉得应该可以进行分表分库,看得出来不是很满意,(还有呢),我觉得从数据持久层上来说,我们进行查询的时候我们可以进行对于binlog进行增量监听,这样可以使得我们进行,其次我们可以再业务执行逻辑的时候我们可以进行异步或者同步的进行更新查询数据(面试官: 实际上我们可以进行构建一个结果表)</p>
</li>
<li><p>讲一下Spring中的aop,什么是动态代理</p>
<p>(卡卡卡卡卡)卡死了,早上明明刚看过的,解释了一下aop的功能,使用,但是讲解原理的时候,疯狂的进行卡顿,动态代理jdk,和cglib都讲了,但是实现给忘了</p>
</li>
<li><p>你说你的项目中使用到了binlog,binlog中的主从延迟是如何进行解决的</p>
<p>八股老知识点了,真服了,就想起了一个延迟读取,现场乱说了一个同步读,(最后面试官补充了进行直接走主库)</p>
</li>
<li><p>项目中的难点有哪些,如何进行解决</p>
<p>继续进行吟唱架构</p>
</li>
<li><p>那么你在架构的技术选型的时候应该也遇到了选型的问题,举个例子,</p>
<p>开始吟唱redis和数据库保持数据一致性的例子,四种不同的技术选型,各自的优劣,为什么进行选择,一套组合拳打爽了</p>
</li>
<li><p>不问技术问题了,开始问如何应对压力</p>
<p>(突然有一个老师闯入,开始给老师道歉…….)继续面试,脑子直接不清楚了,天生乐天派,做好最坏的打算,然后直接开始用力</p>
</li>
<li><p>进入反问环节(继续对于实习生的培养)公司导师制,简单的进行bug检查…..</p>
</li>
<li><p>简单的介绍一下到家,顺便提问了一下,我投的base不是成都吗</p>
<p>介绍了一下到家,然后问我有没有地域的要求(开口就说没有绝对没有,面试官你的base是哪里),北京,(北京好啊,我也喜欢北京…….内心os:真卑微)</p>
</li>
<li><p>几轮面试(就这两轮)</p>
</li>
<li><p>最后问了什么时候最早能来,还有有没有接收到别的公司的offer,然后就进行再说了一下他们的部门是开发,并不是简单的测试</p>
</li>
</ol>
<blockquote>
<p>美团的温柔可算体验到了,二面的面试官真的很温柔,比快手的二面的压力神好多了,反馈感觉十分良好,全程四十分钟,没有手撕,希望oc</p>
</blockquote>
<h1 id="美团-平台直播"><a href="#美团-平台直播" class="headerlink" title="美团(平台直播)"></a>美团(平台直播)</h1><h2 id="美团一面-5-7"><a href="#美团一面-5-7" class="headerlink" title="美团一面(5.7)"></a>美团一面(5.7)</h2><ol>
<li><p>项目介绍? 怎么搞的项目,来介绍一下,你负责的哪一个模块</p>
<p>优惠券领取微服务.优惠券领取的过程,用户如何进行领取在领取的过程中如何进行写redis,如何进行操作,对哪些实体类进行了操作…….(内心os,一番拷打人麻了)</p>
</li>
<li><p>介绍一下java有哪些数据类型</p>
<p>八种数据类型,六种字符型byte,int,long,short,double,float,char,boolean</p>
</li>
<li><p>介绍一下你了解的异常</p>
<p>error,execption,….巴拉巴拉一大堆,有以下情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 正常情况下如何进行执行</span></span><br><span class="line"><span class="comment">  1 3</span></span><br><span class="line"><span class="comment">2. 异常情况下如何进行执行</span></span><br><span class="line"><span class="comment">  1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  System.out.println(temp);</span><br><span class="line">  <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">  <span class="keyword">return</span> ++temp;</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">  System.out.println(temp);</span><br><span class="line">  <span class="keyword">return</span> ++temp;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  System.out.println(tmep);</span><br><span class="line">  <span class="keyword">return</span> ++temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">正常1 1 3</span></span><br><span class="line"><span class="comment">异常1 1 2 3    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>介绍一下ArrayList?读过源码吗?</p>
<p>object[]数组,实现了什么接口,查询效率,O(1),为什么O(1)??????(实现了RandomAccessInterface),所以为什么执行get方法的时候是O(1)的时间复杂度(好似听不懂人话一样)</p>
</li>
<li><p>介绍一下HashMap?读过源码吗?</p>
<p>巴拉巴拉讲了一大堆,讲一下get方法(卡在了n-1 &amp; hashcode之后应该怎么办)</p>
</li>
<li><p>是否是线程安全的? 为什么?jdk1.8</p>
<p>不是(数据覆盖)后面又改口了,真是服了</p>
</li>
<li><p>看你用了很多Redis,来讲一下Redis的数据结构你知道的有哪些,来讲一下</p>
<p>5 种</p>
</li>
<li><p>来讲一下zset底层实现</p>
<p>zset底层是跳表,除了跳表还有什么数据结构(人麻了)</p>
</li>
<li><p>来讲一下Redis中Hash的底层实现</p>
<p>(不知道)</p>
</li>
<li><p>Redis的延时队列实现过吗,如何进行删除过期键</p>
<p>汪汪汪,已经疯了哈哈哈哈哈,懒汉加定时任务</p>
</li>
<li><p>挺了解的话来挑一个你熟悉的Redis的方面</p>
<p>Redis集群(来说一下你对于Redis集群的认识),主从,Sentital,Cluster,巴拉巴拉扯了一大堆,讲到Cluster的时候说了一致性hash,和哈希槽,说了一下一致性hash槽的问题,离谱的来了(如何进行判断hash槽所属于的节点)</p>
</li>
<li><p>Mysql中InnoDB中的索引结构有哪些</p>
<p>不支持Hash(是不能用还是不支持)B+是innoDB使用的,还有b-tree,比较一下(b-tree和b+tree),b-tree在叶子节点既保存索引又保存数据,b+tree只有在叶子节点上保存数据,其余的节点上保存索引,从性能上来说,B+tree更加稳定</p>
</li>
<li><pre><code class="sql">(a,b,c,d,e)
select *
from table
where b = ? and c = ? and d = ?
--能否进行使用索引(不能)
--撤了
select *
from table
where a = ? and b &gt; 10 and c = ?;
--能否进行使用索引(不能)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">14. 来道算java</span><br><span class="line">    </span><br><span class="line">    ```java</span><br><span class="line">    //反转局部链表</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<blockquote>
<p>真的好难,目前为止问的最深的一次,哥们我大三啊,我又不是博三,一直问到一个字都说不出来….md,给哥们拷打的到最后连反问都问不出来了,时间一长脑子容易断片,项目细节还是太差了,继续寄,btw,面试官很有礼貌,但是不如测开的面试官会进行提醒哪些部分出问题了(1h05min)</p>
</blockquote>
<h1 id="腾讯-WXG"><a href="#腾讯-WXG" class="headerlink" title="腾讯(WXG)"></a>腾讯(WXG)</h1><h2 id="腾讯一面-4-23"><a href="#腾讯一面-4-23" class="headerlink" title="腾讯一面(4.23)"></a>腾讯一面(4.23)</h2><ol>
<li><p>自我介绍</p>
<p>啊吧啊吧…..</p>
</li>
<li><p>深挖项目</p>
<p>巨细无比,汗流浃背</p>
</li>
<li><p>TCP的滑动窗口? UDP的滑动窗口</p>
<p>我os:(UDP滑动窗口?)</p>
</li>
<li><p>进程到内存的过程</p>
<p>我os:??????</p>
</li>
<li><p>讲一下多路复用io,select,poll,epoll,select 和 epoll区别</p>
<p>终于爽了一把,科班爽文</p>
</li>
<li><p>进程间的通讯方式</p>
<p>就说了四种,还名字说错了一个……(用过哪些),select,samephore,(select有哪几种类型)开始胡说</p>
</li>
<li><p>linux如何查看服务端口状态</p>
<p>????</p>
</li>
<li><p>来道算法(大数相加)</p>
</li>
<li><p>反问?已经知道寄了,不敢问了</p>
</li>
</ol>
<blockquote>
<p>最汗流浃背的一次,再也不想来腾讯了…..恐怖如斯,唉(45min)</p>
</blockquote>
<h1 id="腾讯-广告部门"><a href="#腾讯-广告部门" class="headerlink" title="腾讯(广告部门)"></a>腾讯(广告部门)</h1><h2 id="腾讯一面-5-21"><a href="#腾讯一面-5-21" class="headerlink" title="腾讯一面(5.21)"></a>腾讯一面(5.21)</h2><ol>
<li><p>项目中的路由选型问题,为什么使用zuul而不使用gateway</p>
<p>乱说一通……</p>
</li>
<li><p>java中的数据类型</p>
<p>少了一个,md,跳了</p>
</li>
<li><p>索引的类型有哪些</p>
<p>就说上了个聚簇和非聚簇(如何进行语句优化)巴拉巴拉,结果自己给自己挖了一个分析器的坑</p>
</li>
<li><p>java中的类有哪些</p>
<p>(<code>内心os</code>)巨巨巨尴尬,md为什么他不说集合类,最后反应了半天才反应过来</p>
</li>
<li><p>网络的协议有哪些,你知道的,smtp协议是什么?</p>
<p>巴拉巴拉</p>
</li>
<li><p>讲一下路由寻址在哪一层</p>
<p>ip秒了,详细的吹了一下</p>
</li>
<li><p><strong>springMVC的流程</strong></p>
<p>下午刚面还没来得及复习就又被拷打</p>
</li>
<li><p><strong>io,select,poll,epoll讲的依托狗屎</strong></p>
</li>
<li><p>JUC讲一下实现</p>
<p>锁,老本行了</p>
</li>
<li><p>finalize和finally的区别</p>
<p>秒了</p>
</li>
<li><p>反问:工作强度,部门是用java吗</p>
</li>
</ol>
<blockquote>
<p>不开摄像头!有被冒犯到,没啥响应,像是kpi,腾讯每日无缘,面试起来真难受,别晚上面了,恶心完了</p>
</blockquote>
<h1 id="腾讯云智-数据库SaaS"><a href="#腾讯云智-数据库SaaS" class="headerlink" title="腾讯云智(数据库SaaS)"></a>腾讯云智(数据库SaaS)</h1><h2 id="腾讯云智一面-5-16"><a href="#腾讯云智一面-5-16" class="headerlink" title="腾讯云智一面(5.16)"></a>腾讯云智一面(5.16)</h2><ol>
<li><p>自我介绍</p>
<p>巴拉巴拉…….</p>
</li>
<li><p>来讲一下操作系统的概念,来讲一下程序是由数据结构和算法组成这句话中的数据结构和算法的意思</p>
<p>操作系统就是提供给用户管理硬件的软件之类的巴拉巴拉……数据结构是提供了一个对于内存的便利操作…..巴拉巴拉(知道哪些数据结构),数组链表,树,图,hash(数据结构知道的算法有哪些)dijistra,prime,KrusialCal</p>
</li>
<li><p>讲一下HashMap,解决冲突的方法</p>
<p>巴拉巴拉</p>
</li>
<li><p>讲一下排序,分治算法有哪些,二分的实现</p>
<p>快排,归并,(大数据如何取出热点数据),topk(感觉讲的有点迷惑,最大堆)</p>
</li>
<li><p>来java,讲一下io,讲一下多线程,讲一下JUC</p>
<p>爽文,狠狠的讲了一番从Synchronize,到AQS,到volatile到五种io,感谢Lei Wang,这点真的受益匪浅QAQ</p>
</li>
<li><p>如何保证线程的有序性</p>
<p>要确保线程执行的有序性，可以采取以下几种方法：</p>
<ol>
<li><p><strong>同步机制：</strong> 使用锁、信号量、互斥量等同步机制来控制线程的执行顺序，确保某些关键代码段只能由一个线程执行，从而保证执行的有序性。</p>
</li>
<li><p><strong>等待&#x2F;通知机制：</strong> 使用条件变量或者其他等待&#x2F;通知机制，让线程在必要时等待某些条件的满足，再由其他线程通知其执行，从而控制线程的执行顺序。<code>join</code></p>
</li>
<li><p><strong>线程调度：</strong> 在多线程环境下，操作系统会对线程进行调度，可以通过设置线程的优先级或者其他调度策略来影响线程的执行顺序。</p>
</li>
<li><p><strong>使用同步队列：</strong> 使用队列等数据结构，将任务按照执行顺序排列，然后由线程按照队列的顺序依次执行任务，从而保证执行的有序性。</p>
</li>
<li><p><strong>使用线程池：</strong> 使用线程池管理线程的执行，通过控制线程的启动和关闭顺序，以及任务的提交顺序，来保证线程执行的有序性。</p>
</li>
</ol>
<p>这些方法可以根据具体的场景和需求来选择和组合使用，以确保线程执行的有序性。</p>
</li>
<li><p>知道哪些数据库,除了关系型</p>
<p>Mysql,sqlserver,Oracle,Nosql:mongoDB,Redis</p>
</li>
<li><p>数据库的优化</p>
<ol>
<li><p>表结构的优化,分表分库,读写分离</p>
</li>
<li><p>explain进行sql语句优化,读哪些字段,type,extra</p>
</li>
<li><p>从数据库缓存进行优化</p>
</li>
<li><p>从硬件进行优化</p>
</li>
</ol>
</li>
<li><p>讲一下,从技术选型和项目的任务进行介绍</p>
<p>SpringCloud+zuul(网关展开)+feign+Hystrix,加缓存和数据库如何进行保证一致性</p>
</li>
<li><p>(换面试官讲项目),分布式事务和分布式锁的理解</p>
<p>卡壳</p>
</li>
<li><p>讲一下定时任务和清除的实现</p>
<p>@Schduled 和 redis中使用expire进行随机时间进行删除(这里可以引入分布式事务)</p>
</li>
<li><p>讲一下第二个应用为什么使用hashmap进行构建索引,而不是用B+tree</p>
<p>这里应该说的是Hashmap可以实现精准匹配的,最后好进行设置规则</p>
</li>
<li><p>手撕单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写了个双重锁还有没进行实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleTon</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> singleTon uniqueInstance;</span><br><span class="line">    singleTon()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleTon <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (uniqueInstance)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">singleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>给哥们三个人轮番拷打,我真的服了,开头直接对着简历一个字一个字的问,有点哈人,不开摄像头太不习惯了,自己对着自己叭叭叭,但是态度挺好还知道好的好的(1h)</p>
</blockquote>
<h2 id="腾讯云智二面-5-20"><a href="#腾讯云智二面-5-20" class="headerlink" title="腾讯云智二面(5.20)"></a>腾讯云智二面(5.20)</h2><ol>
<li><p>博辉在吗,来自我介绍一下<code>内心os</code>:必须得要单独夸一下,这也太温柔了,哭死</p>
<p>阿巴阿巴…..</p>
</li>
<li><p>来说一下未来三年的规划(比如说一下未来想要去的城市,还有怎么打算的之类的)</p>
<p>西安.本来网络是要做运维的,但是我觉得还是后端更加具有挑战性,巴拉巴拉</p>
</li>
<li><p>上来就来了一道场景题,如果有无限插入的数据,我们应该如何提取出最大的一百个数</p>
<p>张嘴就死了,居然有傻呗说了最大堆!!!!淦,最后诱导了一下说了最小堆</p>
</li>
<li><p>说一下如果有一个pub-sub队列,如何在list中进行实现</p>
<p>………再次重申!!!!我是傻逼!这么简单的问题也张嘴就开始胡说了</p>
</li>
<li><p>介绍一下你学校里面学了什么,计算机基础课应该也学了吧</p>
<p>我们学院的开课情况是,网络工程实际上是软件工程,除了编译没学其他的都学了</p>
</li>
<li><p>学过数据库嘛,学了哪些东西</p>
<p>查询,数据库的索引之类的都是自学的</p>
</li>
<li><p>我看你使用了kafka,是实际使用过还是学了理论</p>
<p>用过,然后介绍了一下底层的结构,然后大概说了一下使用的流程</p>
</li>
<li><p>介绍一下项目</p>
<p>极其的舒爽,疯狂巴拉巴拉</p>
</li>
<li><p>说一下有读研的打算嘛,为什么不读研</p>
<p>ai太强了,不走算法没有竞争力,还是想要进行沉淀</p>
</li>
<li><p>什么时候能来,能来实习多久</p>
<p>实习六个月,六月二十号来,(学校有课嘛)没课了,专心实习(姿态很低了)</p>
</li>
<li><p>反问: 咱们的部门是什么</p>
<p>数据库Saas,用来提供云服务的</p>
</li>
</ol>
<blockquote>
<p>腾讯总部总监面!!!!巨佬,巨巨巨温柔,面了十多次第一次见这么温柔的,许愿oc,真的要掉小珍珠了,哭了,还有问我有没有对象,hhhhhhh,笑死我了(20min)</p>
</blockquote>
<h2 id="腾讯云智加面-5-22"><a href="#腾讯云智加面-5-22" class="headerlink" title="腾讯云智加面(5.22)"></a>腾讯云智加面(5.22)</h2><ol>
<li><p>自我介绍</p>
<p>阿巴阿巴</p>
</li>
<li><p>(开始痛苦的一个小时),如果在你写redis进行宕机的话,会有什么情况,如何进行解决</p>
<p>从redis中的持久化的角度来说的话,我觉得可以进行开启aof或者rdb(具体一点),因为我们知道在写的过程实际上会先进行读取命令,所以我们可以对于log文件进行操作</p>
</li>
<li><p>来介绍一下你的服务为什么写在redis中,为什么不是mysql中</p>
<p>实际上进行对于写的时候是写在mysql中的,我觉得可以进行</p>
</li>
<li><p>介绍一下领取优惠券的流程</p>
<p>爽文,开始叭叭</p>
</li>
<li><p>介绍一下,如果在写入redis和数据库的过程中服务宕机了应该怎么办</p>
<p>从持久化的角度上来说我们可以进行回滚,重点保持redis和mysql中的数据的一致性</p>
</li>
<li><p>讲一下结算微服务</p>
<p>巴拉了一下,直接说忘了</p>
</li>
<li><p>你的项目中使用到了kafka吗,在你的项目中的作用是什么</p>
<p>解耦(实现无关业务),异步(优惠券进行过期的时候)</p>
</li>
<li><p>讲一下如何如何进行实现分布式锁</p>
<p>继续装</p>
</li>
<li><p>讲一下为什么两阶段进行提交</p>
<p>分发微服务进行调用结算微服务</p>
</li>
<li><p>kafka的结构介绍</p>
<p>producer,broker,topic,partition,consumer,分区巴拉巴拉(kafka为什么高可用)</p>
</li>
<li><p>redis为什么快</p>
<p>基于内存,特殊的数据结构优化,多路io服用!!!!!!(想给自己来两巴掌),什么是多路复用,把kafka的零拷贝讲了半天!!!!!!</p>
</li>
<li><p>第二个项目进行拷打,如何实现的</p>
<p>binlog-connector</p>
</li>
<li><p>讲一下binlog的流程</p>
<p>写binlog,建立io,之类的</p>
</li>
<li><p>后面还问了什么细节上的实现之类的,狠狠的装了一番</p>
</li>
<li><p>如何进行理解微服务(说的有点差),这两个项目的收获是什么</p>
</li>
</ol>
<blockquote>
<p>狠狠拷打项目,拷打的口干舌燥,一个小时单口相声,面的头红耳赤,最后详细的介绍了一下部门,还不错(50min)</p>
</blockquote>
<h2 id="腾讯云智HR面-5-28"><a href="#腾讯云智HR面-5-28" class="headerlink" title="腾讯云智HR面(5.28)"></a>腾讯云智HR面(5.28)</h2><ol>
<li><p>简单的自我介绍一下</p>
</li>
<li><p>对于前三轮面试的部分有哪些不足和优势</p>
<p>优势: 项目,职业规划回答的还不错</p>
<p>劣势: java的相关的基础知识还是有一点差</p>
</li>
<li><p>对于部门的了解有哪些</p>
<p>属于CSIG事业部,对于腾讯进行对接,数据库SaaS部门对于企业级开发比较核心,能学到很多的东西</p>
</li>
<li><p>成绩?</p>
<p>rank50%(就这还有被冷嘲热讽一下,我真的坠了)</p>
</li>
<li><p>介绍一下项目,哪里来的</p>
<p>腾讯云架构进行选型</p>
</li>
<li><p>中途遇到了错误进行如何解决?</p>
<p>看log文件,为什么不进行别的方法解决.(抛出异常费时间)</p>
</li>
<li><p>学到了哪些知识?</p>
<p>企业级开发的全流程,规划开发(还有哪些项目) 没有进一步的打算,打算进行部署上线,k8s(夸了一下,说就应该有始有终)</p>
</li>
<li><p>有考研的打算吗?为什么不考研</p>
<p>老话术了</p>
</li>
<li><p>有哪些厂的offer,为什么不选测开,你觉得测开对于开发的区别是什么</p>
<p>巴拉巴拉狠狠的夸</p>
</li>
<li><p>开始拷打?挂了几科,为什么挂科,为什么现在才开始准备找实习(9爷怎么会想起找od的)</p>
<p>耻辱……QWQ</p>
</li>
<li><p>介绍了一下公司的待遇,问了一下什么时候能进行入职</p>
</li>
</ol>
<blockquote>
<p>面个hr面为啥还有技术问题,真是服了,打了我当头一棒,还有一种无力感,感觉到回答的很好,就是下来复盘的时候发现了还是有很多的漏洞……..(28min)</p>
</blockquote>
<h1 id="TapTap"><a href="#TapTap" class="headerlink" title="TapTap"></a>TapTap</h1><h2 id="TapTap一面-5-16"><a href="#TapTap一面-5-16" class="headerlink" title="TapTap一面(5.16)"></a>TapTap一面(5.16)</h2><ol>
<li><p>自我介绍,为什么想要做测开,你对于测试开发的流程的了解</p>
</li>
<li><p>如何进行测试流程开发,流程是什么,如何理解黑白盒测试</p>
</li>
<li><p>了解什么是测试流程板吗</p>
</li>
<li><p>了解什么测试工具?</p>
<p>postman,jmeter</p>
</li>
<li><p>什么是压力测试,什么是负载测试</p>
</li>
<li><p>如果要进行一个微信登录界面的测试你应该怎么做</p>
<p>我觉得这是一个形式化验证,我们可以进行对于八种情况进行测试</p>
</li>
<li><p>如果字符串长度为10,我们应该如何进行测试</p>
<p>我觉得可以针对10 和 11 进行测试</p>
</li>
<li><p>讲一下Tcp的三次握手</p>
<p>巴拉巴拉,还有什么是流量控制(巴拉巴拉)</p>
</li>
<li><p>讲一下mysql,什么是内连接,什么是外连接</p>
</li>
<li><p>讲一下优惠券项目的定时任务的实现</p>
</li>
<li><p>了解过自动化测试吗</p>
<p>了解过,pytest(插了一嘴,我想要做的效能工具的开发),然后秒不想聊了</p>
</li>
</ol>
<blockquote>
<p>小姐姐很温柔喵,就是对着八股问我真的服了,问了几句瞬间就没有了聊的欲望,还是all in backend(●ˇ∀ˇ●),测开不适合我(24min)</p>
</blockquote>
<h1 id="精灵云"><a href="#精灵云" class="headerlink" title="精灵云"></a>精灵云</h1><h2 id="精灵云一面-5-21"><a href="#精灵云一面-5-21" class="headerlink" title="精灵云一面(5.21)"></a>精灵云一面(5.21)</h2><ol>
<li><p>自我介绍</p>
<p>阿巴阿巴,有实习经历嘛</p>
</li>
<li><p>讲一下java中的关键字(public,protected,private)</p>
<p>巴拉巴拉</p>
</li>
<li><p>讲一下static,final,syncronized,volitale(分开问的)final修饰方法中的参数会怎样,static的原理,syncronized的实现原理,volitale的原理</p>
<p>讲了一大堆不想复盘了</p>
</li>
<li><p>讲一下hashmap的get和put操作</p>
<p>巴拉巴拉,讲的还是有点差</p>
</li>
<li><p>讲一下你对于树的理解,平衡二叉树,二叉搜索树,红黑树巴拉巴拉</p>
<p>一坨狗屎</p>
</li>
<li><p>讲一下你对于Spring,Spring Boot,Spring Mvc还有Spring Cloud的理解</p>
<p>嫌弃我的八股背的太六了…….又一次死到了MVC的dispatchHandler的过程上了,我的问题…..</p>
</li>
<li><p>讲一下对于数据库的理解</p>
<p>使用过JPA(下去学习一下Mybastis,企业很常用)</p>
</li>
<li><p>反问: 什么是docker云部署</p>
</li>
</ol>
<blockquote>
<p>第一次面小厂,尽管面试官心直口快,但是真的学到了不少的东西,获益颇丰,了解到了自己的java基础还是差的挺远的比以前的面试官更能了解到自己的不足</p>
</blockquote>
<h1 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h1><h2 id="58同城一面-5-22"><a href="#58同城一面-5-22" class="headerlink" title="58同城一面(5.22)"></a>58同城一面(5.22)</h2><ol>
<li><p>问了一下个人相关的经历</p>
<p>巴拉巴拉</p>
</li>
<li><p>java的集合类</p>
<p>collection(list,set,<code>queue</code>)</p>
</li>
<li><p>什么是依赖注入(DI)</p>
<p>乱叭叭了一通,<strong>ans: 依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。其作用是去除Java类之间的依赖关系，实现松耦合，以便于开发测试。</strong></p>
</li>
<li><p>讲一下你知道的设计模式</p>
<p>我真就服了,今天脑子像断弦了一样</p>
<p><img src="C:\Users\Uncle\AppData\Roaming\marktext\images\2024-05-22-10-43-06-image.png"></p>
</li>
<li><p>数据库用的怎么样</p>
<p>只用jpa,会写select语句</p>
</li>
<li><p>如何进行理解java线程</p>
<p>线程的概念巴拉了一下,线程安全</p>
</li>
<li><p>如何进行理解堆和栈(堆中的cms的处理流程是什么)</p>
<p>初始标记(Gcroot进行瞬间关联),调用finalize方法,并发标记,重新标记(需要stop the world),并发清除</p>
</li>
<li><p>讲一下分布式锁,如何进行实现</p>
<p>秒了,项目列举了一下,还是不太熟</p>
</li>
<li><p>你熟悉哪些方面,列举一下</p>
<p>网络编程(被diss了)</p>
</li>
</ol>
<blockquote>
<p>结束的时候面试官真的讲了很多东西,东北面试官真的很实在,一个人从求职规划,如何准备,给足信心,之类的说了很多的东西,问的东西看起来很基础,确实很考验个人对于问题理解,讲了如何进行准备项目之类的,伟大,无需多言,目前排名第一的面试官(30min)</p>
</blockquote>
]]></content>
      <categories>
        <category>review</category>
      </categories>
      <tags>
        <tag>internship</tag>
      </tags>
  </entry>
  <entry>
    <title>summaryTemp</title>
    <url>/2024/05/29/summaryTemp/</url>
    <content><![CDATA[<h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><ol>
<li>首先十分感谢快手一面,春招的第一家面试,给哥们给足了整个三个月的自信心,到现在回看才发现当时的回答有多么的傻逼,但是,七战快手也是没谁了,大工当代孟获哈哈哈</li>
<li>对于基础知识还是准备的不扎实,由于项目的起手难度确实稍微高了一些,直接开始微服务,到五月份才开始意识到了分布式知识的重要性,开始进行准备分布式,但是发现准备的稍微还是有点不充足</li>
<li>infj真的不得不说是一个神奇的人格,e人面前变i,i人面前无敌,整个嘴巴拉巴拉基本上没停过,面试体验最好的还是58,不得不说,体验拉满,给出了很多宝贵的建议</li>
<li>内耗的时候真内耗,两个月每天睡五个小时,搞得现在每天五点钟醒已经成本能反应了,难受</li>
<li>多准备复盘,现在不知不觉复盘已经写了<code>30000</code>字了,亏贼,吓人</li>
<li>关注一手,想起来随时更新……ಥ_ಥ</li>
</ol>
<h1 id="投递情况"><a href="#投递情况" class="headerlink" title="投递情况"></a>投递情况</h1><p>呜呜呜,掉小珍珠了,投了六百家,北上大概投了五百家,结果兜兜转转还是回西安了,宿命论,出不了西北了<br></br><br><em><a href="https://bachman.top/2024/05/29/internship/">实习中大厂投递</a></em> </p>
<h1 id="面试经验复盘"><a href="#面试经验复盘" class="headerlink" title="面试经验复盘"></a>面试经验复盘</h1><p>总的来说,还是十分感谢快手让我在整个最难熬的四五月份活了过来,每天投快手,挂快手,咱们秋招见<br><code>9000</code>字的面试复盘真的不准备打赏一下吗,QAQ(┬┬﹏┬┬)<br></br><br><em><a href="https://bachman.top/2024/05/29/internshipReview/">实习中大厂面试复盘&amp;&amp;心里os</a></em> </p>
]]></content>
      <categories>
        <category>review</category>
      </categories>
      <tags>
        <tag>internship</tag>
      </tags>
  </entry>
</search>
